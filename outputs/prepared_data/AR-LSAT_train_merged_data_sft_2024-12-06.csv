completion,prompt
"# Declarations
people = EnumSort([Lara, Mendel, Nastassia])
foods = EnumSort([fruit_cup, hot_dog, pretzel, shish_kebab])
buys = Function([people, foods] -> [bool])

# Constraints
ForAll([p:people, f:foods], And(buys(p, f) == True, Count([f:foods], buys(p, f)) <= 1)) ::: None of the three buys more than one portion of each kind of food
And(buys(Mendel, hot_dog), Not(buys(Mendel, shish_kebab))) ::: If any of the three buys a hot dog, that person does not also buy a shish kebab
And(buys(Mendel, hot_dog), buys(Mendel, pretzel)) ::: At least one of the three buys a hot dog, and at least one buys a pretzel
And(buys(Mendel, shish_kebab), buys(Nastassia, fruit_cup)) ::: Mendel buys a shish kebab
And(buys(Nastassia, fruit_cup), Not(buys(Lara, fruit_cup))) ::: Neither Lara nor Nastassia buys a pretzel
And(buys(Lara, hot_dog), Not(buys(Mendel, hot_dog))) ::: Mendel does not buy any kind of food that Nastassia buys

# Options
Question ::: If Lara and Mendel buy exactly two kinds of food each, which one of the following statements must be true.
is_exception(is_sat(buys(Lara, hot_dog) == True)) ::: (A)
is_exception(is_sat(buys(Mendel, shish_kebab) == True)) ::: (B)
is_exception(is_sat(buys(Nastassia, fruit_cup) == True)) ::: (C)
is_exception(is_sat(buys(Lara, hot_dog) == True)) ::: (D)
is_exception(is_sat(buys(Lara, fruit_cup) == True)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Lara, Mendel, and Nastassia each buy at least one kind of food from a street vendor who sells only fruit cups, hot dogs, pretzels, and shish kebabs. They make their selections in accordance with the following restrictions: None of the three buys more than one portion of each kind of food. If any of the three buys a hot dog, that person does not also buy a shish kebab. At least one of the three buys a hot dog, and at least one buys a pretzel. Mendel buys a shish kebab. Nastassia buys a fruit cup. Neither Lara nor Nastassia buys a pretzel. Mendel does not buy any kind of food that Nastassia buys.
Question:
If Lara and Mendel buy exactly two kinds of food each, which one of the following statements must be true.
Choices:
(A) Lara buys a fruit cup.
(B) Lara buys a hot dog.
(C) Mendel buys a fruit cup.
(D) There is exactly one kind of food that Lara and Mendel both buy.
(E) There is exactly one kind of food that Lara and Nastassia both buy.
###"
"# Declarations
areas = EnumSort([R, S, T, U])
planes = EnumSort([J, K, L, M])
detection = Function([areas, planes] -> [bool])

# Constraints
ForAll([a:areas, p:planes], And(detection(a, p), Count([a:areas], detection(a, p)) >= 1)) ::: each plane is in at least one of the four areas
And(detection(R, J), Count([a:areas], detection(a, J)) == 2) ::: Part of R intersects T
And(detection(S, K), Count([a:areas], detection(a, K)) == 2) ::: Part of S also intersects T
And(detection(U, M), Count([a:areas], detection(a, M)) == 1) ::: Area U is completely within R and also completely within T
And(detection(R, L), Count([a:areas], detection(a, L)) == 1) ::: L is not in any detection area that M is in
And(detection(T, M), Count([a:areas], detection(a, M)) == 1) ::: M is in exactly one of the areas

# Options
Question ::: If at noon K is within exactly two of the four areas, then which one of the following CANNOT be true at that time?
is_exception(is_sat(detection(R, K) == True)) ::: (A)
is_exception(is_sat(detection(S, K) == True)) ::: (B)
is_exception(is_sat(detection(T, K) == True)) ::: (C)
is_exception(is_sat(detection(R, L) == True)) ::: (D)
is_exception(is_sat(detection(T, L) == True)) :::------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.
Question:
If at noon K is within exactly two of the four areas, then which one of the following CANNOT be true at that time?
Choices:
(A) J is within area T.
(B) K is within area R.
(C) K is within area T.
(D) L is within area R.
(E) L is within area T.
###"
"# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###"
"# Declarations
packages = EnumSort([L, M, N, O, P, S, T])
deliveries = Function([packages] -> [int])
ForAll([p:packages], And(1 <= deliveries(p), deliveries(p) <= 7))

# Constraints
Distinct([p:packages], deliveries(p)) ::: no two packages are delivered at the same time
And(deliveries(P) == 1, Or(deliveries(L) == 1, deliveries(P) == 7)) ::: P is delivered either first or seventh
And(deliveries(N) == 2, Or(deliveries(L) == 2, deliveries(N) == 7)) ::: N is delivered at some time after delivering L
And(deliveries(T) == 3, Or(deliveries(M) == 3, deliveries(T) == 7)) ::: T is delivered at some time after delivering M
And(deliveries(S) == 4, Or(deliveries(M) == 4, deliveries(S) == 7)) ::: S is delivered exactly one package between delivering M and delivering P, whether or not M is delivered before P
And(deliveries(O) == 5, Or(deliveries(L) == 5, deliveries(O) == 7)) ::: O is delivered exactly one package between delivering L and delivering P, whether or not L is delivered before P

# Options
Question ::: If the messenger delivers M at some time after delivering O, the fifth package delivered could be any one of the following EXCEPT:
is_exception(is_sat(deliveries(L) == 5)) ::: (A)
is_exception(is_sat(deliveries(M) == 5)) ::: (B)
is_exception(is_sat(deliveries(N) == 5)) ::: (C)
is_exception(is_sat(deliveries(S) == 5)) ::: (D)
is_exception(is_sat(deliveries(T) == 5)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.
Question:
If the messenger delivers M at some time after delivering O, the fifth package delivered could be any one of the following EXCEPT:
Choices:
(A) L
(B) M
(C) N
(D) S
(E) T
###"
"# Declarations
trains = EnumSort([Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, York])
arrives = Function([trains] -> [int])
ForAll([t:trains], And(1 <= arrives(t), arrives(t) <= 7))

# Constraints
Distinct([t:trains], arrives(t)) ::: no two trains arrive at the same time
And(arrives(York) < arrives(Rockville), arrives(Wooster) < arrives(Rockville)) ::: Either the York or the Wooster arrives fourth
And(arrives(Sunnydale) > arrives(Wooster), arrives(Sunnydale) < arrives(York)) ::: The Sunnydale arrives at some time after the Wooster but at some time before the York
And(arrives(Tilbury) > arrives(Rockville), arrives(Victoria) > arrives(Rockville)) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
And(arrives(Tilbury) < arrives(Victoria), arrives(Victoria) < arrives(Tilbury)) ::: The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury

# Options
Question ::: If the Wooster arrives at some time before the Rockville, then exactly how many different orders are there in which the seven trains could arrive?
is_exception(is_sat(arrives(Wooster) == 4)) ::: (A)
is_exception(is_sat(arrives(Tilbury) == 4)) ::: (B)
is_exception(is_sat(arrives(Victoria) == 4)) ::: (C)
is_exception(is_sat(arrives(York) == 4)) ::: (D)
is_exception(is_sat(arrives(Sunnydale) == 4)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.
Question:
If the Wooster arrives at some time before the Rockville, then exactly how many different orders are there in which the seven trains could arrive?
Choices:
(A) four
(B) five
(C) six
(D) seven
(E) eight
###"
"# Declarations
dogs = EnumSort([greyhound, husky, keeshond, Labrador_retriever, poodle, schnauzer])
owners = EnumSort([Monday, Tuesday, Wednesday])
placed = Function([dogs, owners] -> [bool])

# Constraints
ForAll([d:dogs, o:owners], And(placed(d, o) == True, Count([o:owners], And(placed(d, o) == True)) == 2)) ::: two are placed on Monday, two on Tuesday, and the remaining two on Wednesday
And(placed(greyhound, Monday), placed(husky, Tuesday)) ::: The Labrador retriever is placed on the same day as the poodle
And(placed(greyhound, Monday), placed(keeshond, Tuesday)) ::: If the keeshond is placed on Monday, the greyhound is placed on Tuesday
And(placed(schnauzer, Wednesday), placed(husky, Tuesday)) ::: If the schnauzer is placed on Wednesday, the husky is placed on Tuesday

# Options
Question ::: If the greyhound is placed the day before the poodle, then which one of the following CANNOT be placed on Tuesday?
is_exception(is_sat(placed(greyhound, Monday) == True)) ::: (A)
is_exception(is_sat(placed(husky, Tuesday) == True)) ::: (B)
is_exception(is_sat(placed(keeshond, Tuesday) == True)) ::: (C)
is_exception(is_sat(placed(poodle, Tuesday) == True)) ::: (D)
is_exception(is_sat(placed(schnauzer, Wednesday) == True)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
During a certain week, an animal shelter places exactly six dogs—a greyhound, a husky, a keeshond, a Labrador retriever, a poodle, and a schnauzer—with new owners. Two are placed on Monday, two on Tuesday, and the remaining two on Wednesday, consistent with the following conditions: The Labrador retriever is placed on the same day as the poodle. The greyhound is not placed on the same day as the husky. If the keeshond is placed on Monday, the greyhound is placed on Tuesday. If the schnauzer is placed on Wednesday, the husky is placed on Tuesday.
Question:
If the greyhound is placed the day before the poodle, then which one of the following CANNOT be placed on Tuesday?
Choices:
(A) the husky
(B) the keeshond
(C) the Labrador retriever
(D) the poodle
(E) the schnauzer
###"
"# Declarations
guideposts = EnumSort([1, 2, 3, 4, 5, 6])
pictures = EnumSort([fox, grizzly, hare, lynx, moose, porcupine])
guidepost_number = Function([guideposts] -> [int])

# Constraints
ForAll([g:guideposts], And(1 <= guidepost_number(g), guidepost_number(g) <= 6))
And(guidepost_number(3) == 4, guidepost_number(4) == 3) ::: The grizzly is pictured on either guidepost 3 or guidepost 4
And(guidepost_number(5) == 6, guidepost_number(6) == 5) ::: The moose guidepost is numbered lower than the hare guidepost
And(guidepost_number(2) == 3, guidepost_number(3) == 2) ::: The lynx guidepost is numbered lower than the moose guidepost but higher than the fox guidepost

# Options
Question ::: If the moose guidepost is numbered exactly one higher than the lynx guidepost, then which one of the following could be true?
is_exception(is_sat(guidepost_number(4) == 5)) ::: (A)
is_exception(is_sat(guidepost_number(3) == 4)) ::: (B)
is_exception(is_sat(guidepost_number(4) == 3)) ::: (C)
is_exception(is_sat(guidepost_number(3) == 5)) ::: (D)
is_exception(is_sat(guidepost_number(3) == 4)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly six guideposts, numbered 1 through 6, mark a mountain trail. Each guidepost pictures a different one of six animals—fox, grizzly, hare, lynx, moose, or porcupine. The following conditions must apply: The grizzly is pictured on either guidepost 3 or guidepost 4. The moose guidepost is numbered lower than the hare guidepost. The lynx guidepost is numbered lower than the moose guidepost but higher than the fox guidepost.
Question:
If the moose guidepost is numbered exactly one higher than the lynx guidepost, then which one of the following could be true?
Choices:
(A) Guidepost 5 pictures the hare.
(B) Guidepost 4 pictures the moose.
(C) Guidepost 4 pictures the porcupine.
(D) Guidepost 3 pictures the lynx.
(E) Guidepost 3 pictures the porcupine.
###"
"# Declarations
parcels = EnumSort([G, H, J, K, L, M, N, O])
delivered = Function([parcels] -> [int])
ForAll([p:parcels], And(1 <= delivered(p), delivered(p) <= 8))

# Constraints
Distinct([p:parcels], delivered(p)) ::: no two parcels are delivered at the same time
And(delivered(L) > delivered(H), delivered(O) > delivered(H)) ::: L is delivered later than H
And(delivered(K) < delivered(O), delivered(H) < delivered(M)) ::: K is delivered earlier than O
And(delivered(H) < delivered(M), delivered(G) < delivered(M)) ::: H is delivered earlier than M
And(delivered(O) > delivered(G), delivered(M) > delivered(G)) ::: O is delivered later than G
And(delivered(M) < delivered(G), delivered(N) < delivered(M)) ::: M is delivered earlier than G

# Options
Question ::: If H is the fourth parcel delivered, then each of the following could be true EXCEPT:
is_exception(is_sat(delivered(K) == 4)) ::: (A)
is_exception(is_sat(delivered(L) == 4)) ::: (B)
is_exception(is_sat(delivered(M) == 4)) ::: (C)
is_exception(is_sat(delivered(G) == 4)) ::: (D)
is_exception(is_sat(delivered(O) == 4)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A courier delivers exactly eight parcels—G, H, J, K, L, M, N, and O. No two parcels are delivered at the same time, nor is any parcel delivered more than once. The following conditions must apply: L is delivered later than H. K is delivered earlier than O. H is delivered earlier than M. O is delivered later than G. M is delivered earlier than G. Both N and J are delivered earlier than M.
Question:
If H is the fourth parcel delivered, then each of the following could be true EXCEPT:
Choices:
(A) K is the fifth parcel delivered.
(B) L is the sixth parcel delivered.
(C) M is the sixth parcel delivered.
(D) G is the seventh parcel delivered.
(E) O is the seventh parcel delivered.
###"
"# Declarations
people = EnumSort([Grace, Heather, Josh, Maria])
furniture = EnumSort([recliner, sofa, table])
helps = Function([people, furniture] -> [bool])

# Constraints
ForAll([p:people, f:furniture], And(helps(p, f) == helps(p, f) == True, helps(p, f) == helps(p, f) == False)) ::: each piece of furniture will be moved by exactly two of the people
And(helps(Grace, sofa) == helps(Heather, recliner), helps(Grace, recliner) == helps(Heather, sofa)) ::: Grace helps move the sofa if, but only if, Heather helps move the recliner
And(helps(Josh, table) == helps(Maria, recliner), helps(Josh, recliner) == helps(Maria, table)) ::: Josh helps move the table if, but only if, Maria helps move the recliner
Not(helps(Grace, recliner) == helps(Josh, table)) ::: no piece of furniture is moved by Grace and Josh together

# Options
Question ::: Which one of the following could be an accurate matching of each piece of furniture to the two people who help each other move it?
is_exception(is_sat(helps(Grace, sofa) == helps(Heather, recliner))) ::: (A)
is_exception(is_sat(helps(Josh, table) == helps(Maria, recliner))) ::: (B)
is_exception(is_sat(helps(Heather, sofa) == helps(Grace, recliner))) ::: (C)
is_exception(is_sat(helps(Grace, recliner) == helps(Josh, table))) ::: (D)
is_exception(is_sat(helps(Josh, table) == helps(Maria, recliner))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Four people—Grace, Heather, Josh, and Maria—will help each other move exactly three pieces of furniture—a recliner, a sofa, and a table. Each piece of furniture will be moved by exactly two of the people, and each person will help move at least one of the pieces of furniture, subject to the following constraints: Grace helps move the sofa if, but only if, Heather helps move the recliner. If Josh helps move the table, then Maria helps move the recliner. No piece of furniture is moved by Grace and Josh together.
Question:
Which one of the following could be an accurate matching of each piece of furniture to the two people who help each other move it?
Choices:
(A) recliner: Grace and Maria; sofa: Heather and Josh; table: Grace and Heather
(B) recliner: Grace and Maria; sofa: Heather and Maria; table: Grace and Josh
(C) recliner: Heather and Josh; sofa: Grace and Heather; table: Josh and Maria
(D) recliner: Heather and Josh; sofa: Heather and Maria; table: Grace and Maria
(E) recliner: Josh and Maria; sofa: Grace and Heather; table: Grace and Maria
###"
"# Declarations
films = EnumSort([Fiesta, Glaciers, Hurricanes, Jets, Kangaroos, Lovebird])
release = Function([films] -> [int])

# Constraints
ForAll([f:films], And(1 <= release(f), release(f) <= 6))
ForAll([f:films], And(release(f) == 1, release(f) == 2, release(f) == 3, release(f) == 4, release(f) == 5, release(f) == 6))

# Options
Question ::: Which one of the following, if substituted for the condition that Fiesta must be released earlier than both Jets and Lovebird, would have the same effect on the order in which the films are released?
is_exception(is_sat(release(Fiesta) == 1)) ::: (A)
is_exception(is_sat(release(Kangaroos) == 1)) ::: (B)
is_exception(is_sat(release(Lovebird) == 1)) ::: (C)
is_exception(is_sat(release(Fiesta) == 2)) ::: (D)
is_exception(is_sat(release(Kangaroos) == 2)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A movie studio is scheduling the release of six films—Fiesta, Glaciers, Hurricanes, Jets, Kangaroos, and Lovebird. No two of these films can be released on the same date. The release schedule is governed by the following conditions: Fiesta must be released earlier than both Jets and Lovebird. Kangaroos must be released earlier than Jets, and Jets must be released earlier than Hurricanes. Lovebird must be released earlier than Glaciers.
Question:
Which one of the following, if substituted for the condition that Fiesta must be released earlier than both Jets and Lovebird, would have the same effect on the order in which the films are released?
Choices:
(A) Only Kangaroos can be released earlier than Fiesta.
(B) Kangaroos must be released earlier than Lovebird.
(C) Fiesta must be released either first or second.
(D) Fiesta must be released earlier than both Kangaroos and Lovebird.
(E) Either Fiesta or Kangaroos must be released first.
###"
"# Declarations
books = EnumSort([F, K, N, O, R, T])
discussed = Function([books] -> [int])
summarized = Function([books] -> [bool])

# Constraints
ForAll([b:books], And(1 <= discussed(b), discussed(b) <= 6))
Distinct([b:books], summarized(b)) ::: no two books that are summarized are discussed in consecutive weeks
And(discussed(N) < discussed(R), discussed(T) < discussed(R)) ::: N is discussed earlier than T, and T is discussed earlier than O
And(discussed(O) < discussed(F), discussed(O) < discussed(K)) ::: O is discussed earlier than F, and O is discussed earlier than K
And(discussed(K) < discussed(R), discussed(K) < discussed(N)) ::: K is discussed earlier than R, and K is discussed earlier than N

# Options
Question ::: If N is the second book discussed and it is not summarized, which one of the following could be true?
is_exception(is_sat(discussed(N) == 2)) ::: (A)
is_exception(is_sat(discussed(K) == 2)) ::: (B)
is_exception(is_sat(discussed(O) == 2)) ::: (C)
is_exception(is_sat(discussed(T) == 2)) ::: (D)
is_exception(is_sat(discussed(R) == 2)) ::: (E)
------
Problem:
A group of 10 people is to be seated at a round table. The table has 10 seats, and each person is to be seated at a different seat. The following conditions apply:

1. No two people who are married to each other are seated next to each other.
2. No two people who are siblings are seated next to each other.
3. No two people who are cousins are seated next to each other.
4. No two people who are friends are seated next to each other.
5. No two people who are enemies are seated next to each other.
6. No two people who are coworkers are seated next to each other.
7. No two people who are neighbors are seated next to each other.
8. No two people who are classmates are seated next to each other.
9. No two people who are teammates are seated next to each other.
10. No two people who are roommates are seated next to each other.

Question:
Which one of the following could be the seating arrangement for the group?
Choices:
A) A, B, C, D, E, F, G, H, I, J
B) A, B, C, D, E, F, G, H, I, J
C) A, B, C, D, E, F, G, H, I, J
D) A, B, C, D, E, F, G, H, I, J
E) A, B, C, D, E, F, G, H, I, J
F) A, B, C, D, E, F, G, H, I, J
G) A, B, C, D, E, F, G, H, I, J
H) A, B, C, D, E, F, G, H, I, J
I) A, B, C, D, E, F, G, H, I, J
J) A, B, C, D, E, F, G, H, I, J
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A six-week literature course is being planned in which six books—F, K, N, O, R, and T—will be discussed. The books will be discussed one at a time, one book per week. In addition, written summaries will be required for one or more of the books. The order in which the books are discussed and the selection of books to be summarized is subject to the following conditions: No two books that are summarized are discussed in consecutive weeks. If N is not summarized, then both R and T are summarized. N is discussed earlier than T, and T is discussed earlier than O. F is discussed earlier than O, and O is discussed earlier than both K and R.
Question:
If N is the second book discussed and it is not summarized, which one of the following could be true?
Choices:
(A) F is summarized.
(B) K is summarized.
(C) O is summarized.
(D) T is discussed earlier than F.
(E) The third book discussed is not summarized.
###"
"# Declarations
pencils = EnumSort([green, maroon, orange, red, white, yellow])
used = Function([pencils] -> [bool])
ForAll([p:pencils], And(1 <= used(p), used(p) <= 5))

# Constraints
Distinct([p:pencils], used(p)) ::: no two pencils are used at the same time
And(used(maroon) == False, used(yellow) == False) ::: Either the maroon or the yellow pencil is not used
And(used(red) == True, used(green) == False) ::: The red pencil is used at some time before the green
And(used(red) == True, used(orange) == False) ::: The red pencil is used at some time before either the orange or the yellow, but not before both
And(used(green) == True, used(maroon) == False) ::: The green pencil is used at some time before either the maroon or the white, but not before both

# Options
Question ::: ::: Which one of the following CANNOT be the color of the fifth pencil used?
is_exception(is_sat(used(green) == True)) ::: (A)
is_exception(is_sat(used(maroon) == True)) ::: (B)
is_exception(is_sat(used(orange) == True)) ::: (C)
is_exception(is_sat(used(white) == True)) ::: (D)
is_exception(is_sat(used(yellow) == True)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Meena has six colored pencils—green, maroon, orange, red, white, and yellow. She sketches a drawing using exactly five of the six pencils, one pencil at a time. The following conditions must hold: No pencil is used more than once. Either the maroon or the yellow pencil is not used. The red pencil is used at some time before the green. The red pencil is used at some time before either the orange or the yellow, but not before both. The green pencil is used at some time before either the maroon or the white, but not before both.
Question:
Which one of the following CANNOT be the color of the fifth pencil used?
Choices:
(A) green
(B) maroon
(C) orange
(D) white
(E) yellow
###"
"# Declarations
families = EnumSort([Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans])
houses = EnumSort([1, 2, 3, 4, 5, 6, 7])
lives = Function([families, houses] -> [bool])

# Constraints
ForAll([f:families], Count([h:houses], lives(f, h)) == 1) ::: Each house is occupied by exactly one of seven families
ForAll([h:houses], Count([f:families], lives(f, h)) == 1) ::: There are exactly seven houses on a street
And(lives(Rutans, 1), lives(Rutans, 7)) ::: The Rutans do not live in the first or the last house on the street
lives(Kahns, 4) ::: The Kahns live in the fourth house from the west end of the street
lives(Muirs, 3) ::: The Muirs live next to the Kahns
lives(Piatts, 6) ::: The Piatts live east of both the Kahns and the Muirs but west of the Lowes

# Options
Question ::: If the Newmans live immediately west of the Kahns, which one of the following statements must be false?
is_exception(is_sat(lives(Owens, 1))) ::: (A)
is_exception(is_sat(lives(Owens, 7))) ::: (B)
is_exception(is_sat(lives(Piatts, 5))) ::: (C)
is_exception(is_sat(lives(Piatts, 3))) ::: (D)
is_exception(is_sat(lives(Rutans, 5))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
There are exactly seven houses on a street. Each house is occupied by exactly one of seven families: the Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans. All the houses are on the same side of the street, which runs from west to east. The Rutans do not live in the first or the last house on the street. The Kahns live in the fourth house from the west end of the street. The Muirs live next to the Kahns. The Piatts live east of both the Kahns and the Muirs but west of the Lowes.
Question:
If the Newmans live immediately west of the Kahns, which one of the following statements must be false?
Choices:
(A) The Owens live next to the Newmans.
(B) The Owens live next to the Rutans.
(C) The Piatts live next to the Lowes.
(D) The Piatts live next to the Muirs.
(E) The Rutans live next to the Newmans.
###"
"# Declarations
reviewers = EnumSort([Frank, George, Hilda, Jackie, Karl, Lena])
movies = EnumSort([Mystery, Retreat, Seasonings, Wolves])
reviews = Function([reviewers, movies] -> [bool])

# Constraints
ForAll([r:reviewers], Count([m:movies], reviews(r, m)) == 1) ::: Each reviewer reviews exactly one movie
ForAll([m:movies], Count([r:reviewers], reviews(r, m)) >= 1) ::: each movie is reviewed by at least one of the six reviewers
reviews(Hilda, m) == reviews(Frank, m) ::: Hilda reviews the same movie as Frank
reviews(Lena, m) == reviews(r, m) ::: Lena reviews the same movie as exactly one other reviewer
reviews(George, Mystery) ::: George reviews Mystery
Or(reviews(Jackie, Mystery), reviews(Jackie, Wolves)) ::: Jackie reviews either Mystery or else Wolves
Not(reviews(Hilda, Wolves)) ::: Hilda does not review Wolves

# Options
Question ::: If Lena reviews Seasonings, which one of the following must be true?
is_sat(reviews(Hilda, Retreat)) ::: (A)
is_sat(reviews(Jackie, Seasonings)) ::: (B)
is_sat(reviews(Karl, Mystery)) ::: (C)
is_sat(reviews(Karl, Retreat)) ::: (D)
is_sat(reviews(Karl, Wolves)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.
Question:
If Lena reviews Seasonings, which one of the following must be true?
Choices:
(A) Hilda reviews Retreat.
(B) Jackie reviews Seasonings.
(C) Karl reviews Mystery.
(D) Karl reviews Retreat.
(E) Karl reviews Wolves.
###"
"# Declarations
clans = EnumSort([N, O, P, S, T])
years = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
participates = Function([clans, years] -> [bool])

# Constraints
ForAll([c:clans], Count([y:years], participates(c, y)) >= 3) ::: Each clan must participate at least once in any two consecutive years
ForAll([c:clans], Count([y:years], participates(c, y)) <= 3) ::: No clan participates for three consecutive years
ForAll([c:clans], Count([y:years], participates(c, y)) == 3) ::: Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times

# Options
Question ::: Any cycle for the clans' participation in the ceremonies must be completed at the end of exactly how many years?
is_sat(ForAll([c:clans], Count([y:years], participates(c, y)) == 3)) ::: A) five
is_sat(ForAll([c:clans], Count([y:years], participates(c, y)) == 4)) ::: B) six
is_sat(ForAll([c:clans], Count([y:years], participates(c, y)) == 5)) ::: C)------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.
Question:
Any cycle for the clans' participation in the ceremonies must be completed at the end of exactly how many years?
Choices:
(A) five
(B) six
(C) seven
(D) eight
(E) nine
###"
"# Declarations
houses = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
styles = EnumSort([ranch, split_level, Tudor])
style = Function([houses] -> [styles])

# Constraints
ForAll([h:houses], Count([s:styles], style(h) == s) == 1) ::: Each house will be exactly one of three styles
ForAll([h:houses], Implies(style(h) == style(h + 1), h!= 8)) ::: Adjacent houses are of different styles
ForAll([h:houses], Implies(style(h) == split_level, style(h + 1)!= split_level)) ::: No split-level house faces another split-level house
ForAll([h:houses], Implies(style(h) == ranch, Count([h2:houses], style(h2) == Tudor) >= 1)) ::: Every ranch house has at least one Tudor house adjacent to it
style(3) == ranch ::: House 3 is a ranch house
style(6) == split_level ::: House 6 is a split-level house

# Options
Question ::: If house 4 is a Tudor house, then it could be true that house
is_valid(Exists([h:houses], style(h) == Tudor)) ::: (A)
is_valid(Exists([h:houses], style(h) == Tudor)) ::: (B)
is_valid(Exists([h:houses], style(h) == ranch)) ::: (C)
is_valid(Exists([h:houses], style(h) == Tudor)) ::: (D)
is_valid(Exists([h:houses], style(h) == ranch)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.
Question:
If house 4 is a Tudor house, then it could be true that house
Choices:
(A) 1 is a Tudor house
(B) 2 is a Tudor house
(C) 5 is a ranch house
(D) 7 is a Tudor house
(E) 8 is a ranch house
###"
"# Declarations
houses = EnumSort([1, 3, 5, 7, 2, 4, 6, 8])
styles = EnumSort([ranch, split_level, Tudor])
style = Function([houses] -> [styles])

# Constraints
ForAll([h:houses], Count([s:styles], style(h) == s) == 1) ::: Each house will be exactly one of three styles
ForAll([h:houses], Implies(style(h) == style(h + 1), h!= 8)) ::: Adjacent houses are of different styles
ForAll([h:houses], Implies(style(h) == split_level, style(h + 1)!= split_level)) ::: No split-level house faces another split-level house
ForAll([h:houses], Implies(style(h) == ranch, Count([h2:houses], style(h2) == Tudor) >= 1)) ::: Every ranch house has at least one Tudor house adjacent to it
style(3) == ranch ::: House 3 is a ranch house
style(6) == split_level ::: House 6 is a split-level house

# Options
Question ::: On the street, there could be exactly
is_sat(Count([h:houses], style(h) == ranch) == 1) ::: (A)
is_sat(Count([h:houses], style(h) == Tudor) == 1) ::: (B)
is_sat(Count([h:houses], style(h) == Tudor) == 2) ::: (C)
is_sat(Count([h:houses], style(h) == ranch) == 4) ::: (D)
is_sat(Count([h:houses], style(h) == ranch) == 5) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.
Question:
On the street, there could be exactly
Choices:
(A) one ranch house
(B) one Tudor house
(C) two Tudor houses
(D) four ranch houses
(E) five ranch houses
###"
"# Declarations
people = EnumSort([Jack, Karen, Laura, Mark, Nick, Owen, Peggy, Ruth])
teams = EnumSort([X, Y])
legs = EnumSort([first, second, third, fourth])
runs = Function([people, teams, legs] -> [bool])

# Constraints
ForAll([p:people], Count([t:teams], runs(p, t, first)) == 1) ::: Each team member runs exactly one of the legs
And(runs(Jack, X, first), runs(Karen, X, first)) ::: Jack is on the same team as Karen
And(runs(Karen, X, first), runs(Nick, X, first)) ::: Karen is not on the same team as Nick
And(runs(Ruth, X, first), runs(Peggy, X, first)) ::: Ruth runs an earlier leg of the race than Peggy runs
And(runs(Mark, Y, first), runs(Nick, Y, first)) ::: Mark and Nick are both on team Y
And(runs(Jack, X, third), runs(Mark, X, third)) ::: Neither Jack nor Mark runs third
And(runs(Karen, X, second), runs(Laura, X, second)) ::: Karen and Laura both run second
runs(Owen, X, fourth) ::: Owen runs fourth

# Options
Question ::: Which one of the following must be true?
is_valid(Exists([t:teams], And(runs(Jack, t, first), runs(Owen, t, first)))) ::: (A)
is_valid(Exists([t:teams], And(runs(Jack, t, fourth), runs(Peggy, t, fourth)))) ::: (B)
is_valid(Exists([t:teams], And(runs(Jack, t, third), runs(Ruth, t, third)))) ::: (C)
is_valid(Exists([t:teams], And(runs(Mark, t, fourth), runs(Owen, t, fourth)))) ::: (D)
is_valid(Exists([t:teams], And(runs(Mark, t, third), runs(Ruth, t, third)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Eight people—Jack, Karen, Laura, Mark, Nick, Owen, Peggy, and Ruth—will be placed on two four-person teams—X and Y—for a relay race that is run in four successive legs: first, second, third, and fourth. The teams race concurrently. Each team member runs exactly one of the legs, one team member per leg, according to the following conditions: Jack is on the same team as Karen. Karen is not on the same team as Nick. Ruth runs an earlier leg of the race than Peggy runs, whether or not they are on the same team as each other. Mark and Nick are both on team Y. Neither Jack nor Mark runs third. Karen and Laura both run second. Owen runs fourth.
Question:
Which one of the following must be true?
Choices:
(A) If Jack and Owen are assigned to the same team as each other, Jack runs first.
(B) If Jack and Peggy are assigned to the same team as each other, Jack runs fourth.
(C) If Jack and Ruth are assigned to the same team as each other, Ruth runs third.
(D) If Mark and Owen are assigned to the same team as each other, Mark runs fourth.
(E) If Mark and Ruth are assigned to the same team as each other, Ruth runs third.
###"
"# Declarations
people = EnumSort([Kim, Lina, Maricella, Oliver, Paulo, Shigeru])
sports = EnumSort([golf, tennis])
plays = Function([people, sports] -> [bool])
ranks = Function([people, sports] -> [int])

# Constraints
ForAll([p:people], Count([s:sports], plays(p, s)) == 1) ::: Each of six people plays exactly one of two sports
plays(Oliver, tennis) ::: Oliver plays tennis
plays(Lina, golf) ::: Lina plays golf
ForAll([p:people], And(plays(p, golf), Not(plays(p, tennis)), Count([q:people], And(plays(q, golf), ranks(q, golf) > ranks(p, golf))) == 0)) ::: There is no golf player ranked higher than Lina
And(plays(Maricella, golf), plays(Paulo, golf), plays(Shigeru, golf), ranks(Paulo, golf) > ranks(Maricella, golf), ranks(Shigeru, golf) < ranks(Maricella, golf)) ::: If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru
And(plays(Maricella, tennis), plays(Shigeru, tennis), ranks(Shigeru, tennis) < ranks(Oliver, tennis), ranks(Maricella, tennis) > ranks(Shigeru, tennis)) ::: If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella
And(plays(Paulo, tennis), plays(Kim, tennis), ranks(Oliver, tennis) < ranks(Kim, tennis), ranks(Paulo, tennis) > ranks(Oliver, tennis)) ::: If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo

# Options
Question ::: Each of the following could be the lowest-ranking tennis player EXCEPT:
is_exception(is_sat(ranks(Shigeru, tennis) == 1)) ::: A) Shigeru
is_exception(is_sat(ranks(Kim, tennis) == 1)) ::: B) Kim
is_exception(is_sat(ranks(Oliver, tennis) == 1)) ::: C) Oliver
is_exception(is_sat(ranks(Paulo, tennis) == 1)) ::: D) Paulo------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.
Question:
Each of the following could be the lowest-ranking tennis player EXCEPT:
Choices:
(A) Shigeru
(B) Kim
(C) Oliver
(D) Paulo
(E) Maricella
###"
"# Declarations
songs = EnumSort([F, G, H, R, S, V, X])
plays = Function([songs] -> [int])
ForAll([s:songs], And(1 <= plays(s), plays(s) <= 7))

# Constraints
ForAll([s:songs], Implies(plays(s) == plays(s), s!= s)) ::: no song is played twice
And(plays(F) > plays(R), Implies(plays(G) < plays(R), plays(F) > plays(R))) ::: F must be played immediately after R, unless G is played earlier than R
And(plays(H) < plays(V), plays(V) < plays(S)) ::: H must be played earlier in the sequence than V
And(plays(V) < plays(S), plays(V) + 1 == plays(S)) ::: V and S must be separated from each other by exactly one song
And(plays(S) < plays(F), plays(S) + 1 == plays(F)) ::: S must be played immediately before or immediately after F

# Options
Question ::: Which one of the following could be the first song in the sequence?
is_exception(is_sat(plays(R) == 1)) ::: A) R
is_exception(is_sat(plays(S) == 1)) ::: B) S
is_exception(is_sat(plays(V) == 1)) ::: C) V
is_exception(is_sat(plays(F) == 1)) ::: D) F
is_exception(is_sat(plays(G) == 1)) ::: E) G
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A disc jockey will play a sequence consisting of exactly seven different songs: three ballads—F, G, and H—and four dance tunes—R, S, V, and X. The following conditions must be met: No dance tune can be played immediately after another dance tune. H must be played earlier in the sequence than V. V and S must be separated from each other by exactly one song. S must be played immediately before or immediately after F. F must be played immediately after R, unless G is played earlier than R.
Question:
Which one of the following could be the first song in the sequence?
Choices:
(A) R
(B) S
(C) V
(D) F
(E) G
###"
"# Declarations
packages = EnumSort([L, M, N, O, P, S, T])
delivered = Function([packages] -> [int])
ForAll([p:packages], And(1 <= delivered(p), delivered(p) <= 7))

# Constraints
And(delivered(P) == 1, delivered(P) == 7) ::: P is delivered either first or seventh
And(delivered(N) > delivered(L), delivered(N) < delivered(O)) ::: The messenger delivers N at some time after delivering L
And(delivered(T) > delivered(M), delivered(T) < delivered(P)) ::: The messenger delivers T at some time after delivering M
And(delivered(L) < delivered(O), delivered(O) < delivered(L)) ::: The messenger delivers exactly one package between delivering L and delivering O
And(delivered(M) < delivered(P), delivered(P) < delivered(M)) ::: The messenger delivers exactly one package between delivering M and delivering P

# Options
Question ::: If N is delivered fourth, which one of the following could be true?
is_exception(is_sat(delivered(L) == 1)) ::: A) L is delivered first.
is_exception(is_sat(delivered(L) == 2)) ::: B) L is delivered second.
is_exception(is_sat(delivered(M) == 3)) ::: C) M is delivered third.
is_exception(is_sat(delivered(O) == 5)) ::: D) O is delivered fifth.
is_exception(is_sat(delivered(S) == 1)) ::: E) S is delivered first.
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.
Question:
If N is delivered fourth, which one of the following could be true?
Choices:
(A) L is delivered first.
(B) L is delivered second.
(C) M is delivered third.
(D) O is delivered fifth.
(E) S is delivered first.
###"
"# Declarations
packages = EnumSort([L, M, N, O, P, S, T])
delivered = Function([packages] -> [int])
ForAll([p:packages], And(1 <= delivered(p), delivered(p) <= 7))

# Constraints
Distinct([p:packages], delivered(p)) ::: The seven deliveries must be made according to the following conditions
And(delivered(P) == 1, delivered(P) == 7) ::: P is delivered either first or seventh
And(delivered(N) > delivered(L), delivered(N) < delivered(O)) ::: The messenger delivers N at some time after delivering L
And(delivered(T) > delivered(M), delivered(T) < delivered(P)) ::: The messenger delivers T at some time after delivering M
And(delivered(L) < delivered(O), delivered(L) > delivered(O)) ::: The messenger delivers exactly one package between delivering L and delivering O
And(delivered(M) < delivered(P), delivered(M) > delivered(P)) ::: The messenger delivers exactly one package between delivering M and delivering P

# Options
Question ::: If the messenger delivers M at some time after delivering O, the fifth package delivered could be any one of the following EXCEPT:
is_exception(is_sat(delivered(L) == 5)) ::: A) L
is_exception(is_sat(delivered(M) == 5)) ::: B) M
is_exception(is_sat(delivered(N) == 5)) ::: C) N
is_exception(is_sat(delivered(S) == 5)) ::: D) S
is_exception(is_sat(delivered(T) == 5)) ::: E) T
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.
Question:
If the messenger delivers M at some time after delivering O, the fifth package delivered could be any one of the following EXCEPT:
Choices:
(A) L
(B) M
(C) N
(D) S
(E) T
###"
"# Declarations
boats = EnumSort([Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, Valhalla])
arrived = Function([boats] -> [int])
ForAll([b:boats], And(1 <= arrived(b), arrived(b) <= 8))

# Constraints
Distinct([b:boats], arrived(b)) ::: No boat arrived at the same time as any other boat
And(arrived(Tornado) < arrived(Spain), arrived(Tornado) > arrived(Jewel)) ::: Tornado arrived before Spain but after Jewel
arrived(Neptune) < arrived(Tornado) ::: Neptune arrived before Tornado
arrived(Kashmir) > arrived(Jewel) ::: Kashmir arrived after Jewel
arrived(Kashmir) < arrived(Spain) ::: Kashmir arrived after Jewel but before Spain
arrived(Spain) < arrived(Ojibwa) ::: Spain arrived before Ojibwa

# Options
Question ::: Of the boats, what are, respectively, the minimum number and the maximum number that could have arrived before Kashmir?
is_sat(ForAll([b:boats], Implies(arrived(b) < arrived(Kashmir), b!= Kashmir))) ::: A) one, five
is_sat(ForAll([b:boats], Implies(arrived(b) < arrived(Kashmir), b!= Kashmir))) ::: B) two, five
is_sat(ForAll([b:boats], Implies(arrived(b) < arrived(Kashmir), b!= Kashmir))) ::: C) three, five
is_sat(ForAll([b:boats], Implies(arrived(b) < arrived(Kashmir), b!= Kashmir))) ::: D) one, six
is_sat(ForAll([b:boats], Implies(arrived(b) < arrived(Kashmir), b!= Kashmir))) ::: E) two, six
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.
Question:
Of the boats, what are, respectively, the minimum number and the maximum number that could have arrived before Kashmir?
Choices:
(A) one, five
(B) two, five
(C) three, five
(D) one, six
(E) two, six
###"
"# Declarations
trees = EnumSort([firs, laurels, maples, oaks, pines, spruces, yews])
in_park = Function([trees] -> [bool])

# Constraints
ForAll([t:trees], Count([t:trees], in_park(t)) <= 5) ::: A park contains at most five of seven kinds of trees
Implies(in_park(maples), Not(in_park(yews))) ::: If maples are in the park, yews are not
Implies(in_park(firs), Not(in_park(pines))) ::: If firs are in the park, pines are not
Implies(Not(in_park(yews)), Or(in_park(laurels), in_park(oaks))) ::: If yews are not in the park, then either laurels or oaks, but not both, are in the park
Implies(Not(Or(in_park(laurels), in_park(oaks))), And(in_park(firs), in_park(spruces))) ::: If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces

# Options
Question ::: If neither maples nor spruces are in the park, then which one of the following could be true?
is_valid(Exists([t:trees], in_park(t))) ::: A) Exactly four kinds of trees are in the park.
is_valid(Exists([t:trees], in_park(t))) ::: B) Exactly five kinds of trees are in the park.
is_valid(Exists([t:trees], Not(in_park(t)))) ::: C) Laurels are not in the park.
is_valid(Exists([t:trees], Not(in_park(t)))) ::: D) Oaks are not in the park.
is_valid(Exists([t:trees], Not(in_park(t)))) ::: E) Yews are not in the park.
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.
Question:
If neither maples nor spruces are in the park, then which one of the following could be true?
Choices:
(A) Exactly four kinds of trees are in the park.
(B) Exactly five kinds of trees are in the park.
(C) Laurels are not in the park.
(D) Oaks are not in the park.
(E) Yews are not in the park.
###"
"# Declarations
trains = EnumSort([Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, York])
arrives = Function([trains] -> [int])
ForAll([t:trains], And(1 <= arrives(t), arrives(t) <= 7))

# Constraints
Distinct([t:trains], arrives(t)) ::: The trains arrive one at a time
Or(arrives(York) == 4, arrives(Wooster) == 4) ::: Either the York or the Wooster arrives fourth
And(arrives(Sunnydale) > arrives(Wooster), arrives(Sunnydale) < arrives(York)) ::: The Sunnydale arrives at some time after the Wooster but at some time before the York
And(arrives(Tilbury) > arrives(Rockville), arrives(Victoria) > arrives(Rockville)) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
And(arrives(Tilbury)!= arrives(Victoria) + 1, arrives(Victoria)!= arrives(Tilbury) + 1) ::: The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury

# Options
Question ::: Which one of the following must be true?
is_valid(arrives(Rockville) == 1) ::: (A)
is_valid(arrives(Quigley) < arrives(Sunnydale)) ::: (B)
is_valid(arrives(Rockville) < arrives(Wooster)) ::: (C)
is_valid(arrives(Victoria) < arrives(York)) ::: (D)
is_valid(arrives(Wooster) < arrives(York)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.
Question:
Which one of the following must be true?
Choices:
(A) The first train to arrive is the Rockville.
(B) The Quigley arrives at some time before the Sunnydale.
(C) The Rockville arrives at some time before the Wooster.
(D) The Victoria arrives at some time before the York.
(E) The Wooster arrives at some time before the York.
###"
"# Declarations
astronauts = EnumSort([F, J, K, L, M, N, P, T])
experienced = EnumSort([F, J, K, L])
inexperienced = EnumSort([M, N, P, T])
geologists = EnumSort([F, M, P, T])
radiobiologists = EnumSort([J, K, L, N])
selected = Function([astronauts] -> [bool])

# Constraints
ForAll([a:astronauts], Or(selected(a), Not(selected(a)))) ::: Exactly two experienced astronauts and two inexperienced astronauts are selected
And(selected(F), selected(M), selected(P), selected(T)) ::: Exactly two geologists and two radiobiologists are selected
Or(selected(P), selected(L), And(selected(P), selected(L))) ::: Either P or L or both are selected

# Options
Question ::: If N is selected for the space flight, which one of the following must also be selected?
is_sat(And(selected(N), selected(F))) ::: (A)
is_sat(And(selected(N), selected(J))) ::: (B)
is_sat(And(selected(N), selected(L))) ::: (C)
is_sat(And(selected(N), selected(M))) ::: (D)
is_sat(And(selected(N), selected(T))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
From among eight candidates, four astronauts will be selected for a space flight. Four of the candidates—F, J, K, and L—are experienced astronauts and four—M, N, P, and T—are inexperienced astronauts. F, M, P, and T are geologists whereas J, K, L, and N are radiobiologists. The astronauts must be selected according to the following conditions: Exactly two experienced astronauts and two inexperienced astronauts are selected. Exactly two geologists and two radiobiologists are selected. Either P or L or both are selected.
Question:
If N is selected for the space flight, which one of the following must also be selected?
Choices:
(A) F
(B) J
(C) L
(D) M
(E) T
###"
"# Declarations
medications = EnumSort([F, G, H, I, K, L, M])
ranks = Function([medications] -> [int])
ForAll([m:medications], And(1 <= ranks(m), ranks(m) <= 5))

# Constraints
Distinct([m:medications], ranks(m)) ::: There are no ties
ranks(L) == 2 ::: L ranks second
Or(ranks(F) == 1, ranks(G) == 1) ::: Either F or G ranks first
ranks(I) == 1 ::: I is tested
Implies(ranks(H) == 1, ranks(G) == 2) ::: H ranks better than G if both are tested
Implies(ranks(K) == 1, ranks(F) == 2) ::: K ranks better than F if both are tested
Implies(ranks(M) == 1, And(ranks(F) == 1, ranks(H) == 1)) ::: If M is tested, both F and H are also tested

# Options
Question ::: Which one of the following cold medications must be among those tested in the study?
is_exception(is_sat(ranks(F) == 1)) ::: A) F
is_exception(is_sat(ranks(G) == 1)) ::: B) G
is_exception(is_sat(ranks(H) == 1)) ::: C) H
is_exception(is_sat(ranks(K) == 1)) ::: D) K
is_exception(is_sat(ranks(M) == 1)) ::: E) M
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A study sponsored by a consumer group tests exactly five of seven cold medications—F, G, H, I, K, L, and M—and ranks the medications tested from first (best) to fifth (worst). There are no ties. The following conditions must apply: L ranks second. Either F or G ranks first. I is tested. H ranks better than G if both are tested. K ranks better than F if both are tested. If M is tested, both F and H are also tested.
Question:
Which one of the following cold medications must be among those tested in the study?
Choices:
(A) F
(B) G
(C) H
(D) K
(E) M
###"
"# Declarations
animals = EnumSort([F, G, H, K, L, N, T, V, Z])
selected = Function([animals] -> [bool])
ForAll([a:animals], And(selected(a) == true, selected(a) == false))

# Constraints
ForAll([a:animals], And(1 <= Count([a:animals], selected(a)), Count([a:animals], selected(a)) <= 6)) ::: exactly six individual animals
Implies(selected(F), Not(selected(H))) ::: F and H are not both selected
Implies(selected(N), Not(selected(T))) ::: N and T are not both selected
Implies(selected(H), selected(K)) ::: If H is selected, K is also selected
Implies(selected(K), selected(N)) ::: If K is selected, N is also selected

# Options
Question ::: If H and L are among the animals selected, which one of the following could be true?
is_sat(And(selected(F), selected(H), selected(L))) ::: (A)
is_sat(And(selected(T), selected(H), selected(L))) ::: (B)
is_sat(And(selected(Z), selected(H), selected(L))) ::: (C)
is_sat(And(selected(H), selected(L), Count([a:animals], selected(a)) == 1)) ::: (D)
is_sat(And(selected(H), selected(L), Count([a:animals], selected(a)) == 2)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.
Question:
If H and L are among the animals selected, which one of the following could be true?
Choices:
(A) F is selected.
(B) T is selected.
(C) Z is selected.
(D) Exactly one panda is selected.
(E) Exactly two pandas are selected.
###"
"# Declarations
animals = EnumSort([F, G, H, K, L, N, T, V, Z])
selected = Function([animals] -> [bool])
ForAll([a:animals], And(selected(a) == true, selected(a) == false))

# Constraints
Not(And(selected(F), selected(H))) ::: F and H are not both selected
Not(And(selected(N), selected(T))) ::: N and T are not both selected
Implies(selected(H), selected(K)) ::: If H is selected, K is also selected
Implies(selected(K), selected(N)) ::: If K is selected, N is also selected

# Options
Question ::: Each of the following is a pair of animals that could be selected together EXCEPT
is_exception(is_sat(And(selected(F), selected(G)))) ::: (A)
is_exception(is_sat(And(selected(H), selected(K)))) ::: (B)
is_exception(is_sat(And(selected(K), selected(T)))) ::: (C)
is_exception(is_sat(And(selected(L), selected(N)))) ::: (D)
is_exception(is_sat(And(selected(T), selected(V)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.
Question:
Each of the following is a pair of animals that could be selected together EXCEPT
Choices:
(A) F and G
(B) H and K
(C) K and T
(D) L and N
(E) T and V
###"
"# Declarations
animals = EnumSort([F, G, H, K, L, N, T, V, Z])
selected = Function([animals] -> [bool])
ForAll([a:animals], And(selected(a) == true, selected(a) == false))

# Constraints
Not(And(selected(F), selected(H))) ::: F and H are not both selected
Not(And(selected(N), selected(T))) ::: N and T are not both selected
Implies(selected(H), selected(K)) ::: If H is selected, K is also selected
Implies(selected(K), selected(N)) ::: If K is selected, N is also selected

# Options
Question ::: If T is selected, which one of the following is a pair of animals that must be among the animals selected?
is_sat(And(selected(F), selected(G))) ::: (A)
is_sat(And(selected(G), selected(H))) ::: (B)
is_sat(And(selected(K), selected(L))) ::: (C)
is_sat(And(selected(K), selected(Z))) ::: (D)
is_sat(And(selected(L), selected(N))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.
Question:
If T is selected, which one of the following is a pair of animals that must be among the animals selected?
Choices:
(A) F and G
(B) G and H
(C) K and L
(D) K and Z
(E) L and N
###"
"# Declarations
committee = EnumSort([French, Ghauri, Hsia, Irving, Magnus, Pinsky])
subcommittees = EnumSort([A, B, C])
serves = Function([committee, subcommittees] -> [bool])

# Constraints
ForAll([c:committee], Count([s:subcommittees], serves(c, s)) >= 1) ::: each committee member serves on at least one subcommittee
ForAll([s:subcommittees], Count([c:committee], serves(c, s)) == 3) ::: each subcommittee has three members
Implies(serves(French, s), Not(serves(Ghauri, s))) ::: French does not serve on any subcommittee with Ghauri
Implies(serves(Hsia, s), Not(serves(Irving, s))) ::: Hsia does not serve on any subcommittee with Irving

# Options
Question ::: Which one of the following must be true?
is_valid(ForAll([s:subcommittees], Or(serves(French, s), serves(Ghauri, s)))) ::: (A)
is_valid(ForAll([s:subcommittees], Or(serves(Hsia, s), serves(Irving, s)))) ::: (B)
is_valid(ForAll([s:subcommittees], Not(Or(serves(French, s), serves(Magnus, s), serves(Pinsky, s))))) ::: (C)
is_valid(Exists([c:committee], Count([s:subcommittees], serves(c, s)) == 2)) ::: (D)
is_valid(Exists([c:committee], Or(serves(c, A), serves(c, B), serves(c, C)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A reporter is trying to uncover the workings of a secret committee. The committee has six members—French, Ghauri, Hsia, Irving, Magnus, and Pinsky—each of whom serves on at least one subcommittee. There are three subcommittees, each having three members, about which the following is known: One of the committee members serves on all three subcommittees. French does not serve on any subcommittee with Ghauri. Hsia does not serve on any subcommittee with Irving.
Question:
Which one of the following must be true?
Choices:
(A) Every subcommittee has either French or Ghauri as a member.
(B) Every subcommittee has either Hsia or Irving as a member.
(C) No subcommittee consists of French, Magnus, and Pinsky.
(D) Some committee member serves on exactly two subcommittees.
(E) Either Magnus or Pinsky serves on only one subcommittee.
###"
"# Declarations
courses = EnumSort([geography, history, literature, mathematics, psychology, sociology, zoology])
offered = Function([courses] -> [bool])

# Constraints
ForAll([c:courses], Count([c:courses], offered(c)) >= 1) ::: A summer program offers at least one of the following seven courses
And(offered(mathematics), Or(offered(literature), offered(sociology))) ::: If mathematics is offered, then either literature or sociology (but not both) is offered
And(offered(literature), And(offered(geography), Not(offered(psychology)))) ::: If literature is offered, then geography is also offered but psychology is not
And(offered(sociology), And(offered(psychology), Not(offered(zoology)))) ::: If sociology is offered, then psychology is also offered but zoology is not
And(offered(geography), And(offered(history), offered(zoology))) ::: If geography is offered, then both history and zoology are also offered

# Options
Question ::: If history is not offered by the summer program, then which one of the following is another course that CANNOT be offered?
is_exception(is_sat(And(Not(offered(history)), offered(literature)))) ::: A)
is_exception(is_sat(And(Not(offered(history)), offered(mathematics)))) ::: B)
is_exception(is_sat(And(Not(offered(history)), offered(psychology)))) ::: C)
is_exception(is_sat(And(Not(offered(history)), offered(sociology)))) ::: D)
is_exception(is_sat(And(Not(offered(history)), offered(zoology)))) ::: E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A summer program offers at least one of the following seven courses: geography, history, literature, mathematics, psychology, sociology, zoology. The following restrictions on the program must apply: If mathematics is offered, then either literature or sociology (but not both) is offered. If literature is offered, then geography is also offered but psychology is not. If sociology is offered, then psychology is also offered but zoology is not. If geography is offered, then both history and zoology are also offered.
Question:
If history is not offered by the summer program, then which one of the following is another course that CANNOT be offered?
Choices:
(A) literature
(B) mathematics
(C) psychology
(D) sociology
(E) zoology
###"
"# Declarations
suites = EnumSort([F, G, H, J, K, L])
ranks = Function([suites] -> [int])
ForAll([s:suites], And(1 <= ranks(s), ranks(s) <= 6))

# Constraints
Distinct([s:suites], ranks(s)) ::: There are no ties
ranks(H) > ranks(L) ::: H is more expensive than L
And(ranks(G) > ranks(H), Implies(ranks(K) > ranks(J), ranks(L) > ranks(J))) ::: If G is more expensive than H, then neither K nor L is more expensive than J
And(ranks(H) > ranks(G), Implies(ranks(J) > ranks(K), ranks(J) > ranks(L))) ::: If H is more expensive than G, then neither J nor L is more expensive than K
Or(ranks(F) > ranks(G), ranks(F) > ranks(H)) ::: F is more expensive than G, or else F is more expensive than H, but not both

# Options
Question ::: Which one of the following CANNOT be the most expensive suite?
is_exception(is_sat(ranks(F) == 1)) ::: A) F
is_exception(is_sat(ranks(G) == 1)) ::: B) G
is_exception(is_sat(ranks(H) == 1)) ::: C) H
is_exception(is_sat(ranks(J) == 1)) ::: D) J
is_exception(is_sat(ranks(K) == 1)) ::: E) K
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Six hotel suites—F, G, H, J, K, L—are ranked from most expensive (first) to least expensive (sixth). There are no ties. The ranking must be consistent with the following conditions: H is more expensive than L. If G is more expensive than H, then neither K nor L is more expensive than J. If H is more expensive than G, then neither J nor L is more expensive than K. F is more expensive than G, or else F is more expensive than H, but not both.
Question:
Which one of the following CANNOT be the most expensive suite?
Choices:
(A) F
(B) G
(C) H
(D) J
(E) K
###"
"# Declarations
saxophonists = EnumSort([Fujimura, Gabrieli, Herman, Jackson, King, Lauder])
auditions = Function([saxophonists] -> [int])

# Constraints
ForAll([s:saxophonists], And(1 <= auditions(s), auditions(s) <= 6)) ::: Each audition will begin on the hour, with the first beginning at 1 P.M. and the last at 6 P.M.
And(auditions(Jackson) < auditions(Herman), auditions(Gabrieli) < auditions(King)) ::: Jackson auditions earlier than Herman does. Gabrieli auditions earlier than King does.
And(auditions(Gabrieli) == auditions(Lauder) - 1, auditions(Gabrieli) == auditions(Lauder) + 1) ::: Gabrieli auditions either immediately before or immediately after Lauder does.
auditions(Jackson) + 1 == auditions(Lauder) ::: Exactly one audition separates the auditions of Jackson and Lauder.

# Options
Question ::: If Fujimura's audition is not scheduled to begin at 1 P.M., which one of the following could be true?
is_exception(is_sat(auditions(Herman) == 6)) ::: (A)
is_exception(is_sat(auditions(Gabrieli) == 5)) ::: (B)
is_exception(is_sat(auditions(Herman) == 3)) ::: (C)
is_exception(is_sat(auditions(Jackson) == 2)) ::: (D)
is_exception(is_sat(auditions(Jackson) == 5)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Individual hour-long auditions will be scheduled for each of six saxophonists—Fujimura, Gabrieli, Herman, Jackson, King, and Lauder. The auditions will all take place on the same day. Each audition will begin on the hour, with the first beginning at 1 P.M. and the last at 6 P.M. The schedule of auditions must conform to the following conditions: Jackson auditions earlier than Herman does. Gabrieli auditions earlier than King does. Gabrieli auditions either immediately before or immediately after Lauder does. Exactly one audition separates the auditions of Jackson and Lauder.
Question:
If Fujimura's audition is not scheduled to begin at 1 P.M., which one of the following could be true?
Choices:
(A) Herman's audition is scheduled to begin at 6 P.M.
(B) Gabrieli's audition is scheduled to begin at 5 P.M.
(C) Herman's audition is scheduled to begin at 3 P.M.
(D) Jackson's audition is scheduled to begin at 2 P.M.
(E) Jackson's audition is scheduled to begin at 5 P.M.
###"
"# Declarations
people = EnumSort([Grace, Heather, Josh, Maria])
furniture = EnumSort([recliner, sofa, table])
moves = Function([people, furniture] -> [bool])

# Constraints
ForAll([p:people], Count([f:furniture], moves(p, f)) >= 1) ::: each person will help move at least one of the pieces of furniture
ForAll([f:furniture], Count([p:people], moves(p, f)) == 2) ::: each piece of furniture will be moved by exactly two of the people
Implies(moves(Grace, sofa), moves(Heather, recliner)) ::: Grace helps move the sofa if, but only if, Heather helps move the recliner
Implies(moves(Josh, table), moves(Maria, recliner)) ::: If Josh helps move the table, then Maria helps move the recliner
ForAll([p:people], Implies(p == Grace, Not(p == Josh))) ::: No piece of furniture is moved by Grace and Josh together

# Options
Question ::: Which one of the following could be an accurate matching of each piece of furniture to the two people who help each other move it?
is_sat(And(moves(Grace, recliner), moves(Maria, recliner), moves(Heather, sofa), moves(Josh, sofa), moves(Grace, table), moves(Heather, table))) ::: (A)
is_sat(And(moves(Grace, recliner), moves(Maria, recliner), moves(Heather, sofa), moves(Maria, sofa), moves(Grace, table), moves(Josh, table))) ::: (B)
is_sat(And(moves(Heather, recliner), moves(Josh, recliner), moves(Grace, sofa), moves(Heather, sofa), moves(Josh, table), moves(Maria, table))) ::: (C)
is_sat(And(moves(Heather, recliner), moves(Josh, recliner), moves(Heather, sofa), moves(Maria, sofa), moves(Josh, table), moves(Maria, table))) ::: (D)
is_sat(And(moves(Josh, recliner), moves(Maria, recliner), moves(Grace, sofa), moves(Heather, sofa), moves(Grace, table), moves(Maria, table))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Four people—Grace, Heather, Josh, and Maria—will help each other move exactly three pieces of furniture—a recliner, a sofa, and a table. Each piece of furniture will be moved by exactly two of the people, and each person will help move at least one of the pieces of furniture, subject to the following constraints: Grace helps move the sofa if, but only if, Heather helps move the recliner. If Josh helps move the table, then Maria helps move the recliner. No piece of furniture is moved by Grace and Josh together.
Question:
Which one of the following could be an accurate matching of each piece of furniture to the two people who help each other move it?
Choices:
(A) recliner: Grace and Maria; sofa: Heather and Josh; table: Grace and Heather
(B) recliner: Grace and Maria; sofa: Heather and Maria; table: Grace and Josh
(C) recliner: Heather and Josh; sofa: Grace and Heather; table: Josh and Maria
(D) recliner: Heather and Josh; sofa: Heather and Maria; table: Grace and Maria
(E) recliner: Josh and Maria; sofa: Grace and Heather; table: Grace and Maria
###"
"# Declarations
parents = EnumSort([Felicia, Leah, Masatomo, Rochelle, Salman, Terry, Veena])
volunteers = Function([parents] -> [bool])

# Constraints
ForAll([p:parents], Implies(volunteers(p), p!= Rochelle)) ::: The composition of the volunteer group must be consistent with the following: If Rochelle volunteers, then so does Masatomo.
ForAll([p:parents], Implies(volunteers(p), p!= Masatomo)) ::: If Masatomo volunteers, then so does Terry.
ForAll([p:parents], Implies(volunteers(p), p!= Salman)) ::: If Salman does not volunteer, then Veena volunteers.
ForAll([p:parents], Implies(volunteers(p), p!= Rochelle)) ::: If Rochelle does not volunteer, then Leah volunteers.
ForAll([p:parents], Implies(volunteers(p), p!= Terry)) ::: If Terry volunteers, then neither Felicia nor Veena volunteers.

# Options
Question ::: If Terry does not volunteer, then which one of the following CANNOT be true?
is_exception(is_sat(volunteers(Felicia))) ::: A) Felicia volunteers.
is_exception(is_sat(volunteers(Leah))) ::: B) Leah volunteers.
is_exception(is_sat(volunteers(Rochelle))) ::: C) Rochelle volunteers.
is_exception(is_sat(volunteers(Salman)))------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A company organizing on-site day care consults with a group of parents composed exclusively of volunteers from among the seven employees—Felicia, Leah, Masatomo, Rochelle, Salman, Terry, and Veena—who have become parents this year. The composition of the volunteer group must be consistent with the following: If Rochelle volunteers, then so does Masatomo. If Masatomo volunteers, then so does Terry. If Salman does not volunteer, then Veena volunteers. If Rochelle does not volunteer, then Leah volunteers. If Terry volunteers, then neither Felicia nor Veena volunteers.
Question:
If Terry does not volunteer, then which one of the following CANNOT be true?
Choices:
(A) Felicia volunteers.
(B) Leah volunteers.
(C) Rochelle volunteers.
(D) Salman volunteers.
(E) Veena volunteers.
###"
"# Declarations
actors = EnumSort([Geyer, Henson, Jhalani, Lin, Mitchell, Paredes])
appears = Function([actors] -> [int])
ForAll([a:actors], And(1 <= appears(a), appears(a) <= 6))

# Constraints
And(appears(Lin) < appears(Henson), appears(Mitchell) < appears(Henson)) ::: Both Lin and Mitchell appear earlier than Henson
And(appears(Lin) < appears(Jhalani), appears(Paredes) < appears(Jhalani)) ::: Both Lin and Paredes appear earlier than Jhalani
And(appears(Mitchell) < appears(Paredes), appears(Henson) < appears(Geyer)) ::: If Mitchell appears earlier than Paredes, then Henson appears earlier than Geyer
appears(Geyer)!= 6 ::: Geyer does not appear last

# Options
Question ::: If Jhalani appears earlier than Mitchell, then which one of the following could be the order in which the other four actors appear, from earliest to latest?
is_exception(is_sat(And(appears(Geyer) == 1, appears(Lin) == 2, appears(Paredes) == 3, appears(Henson) == 4))) ::: A) Geyer, Lin, Paredes, Henson
is_exception(is_sat(And(appears(Geyer) == 1, appears(Paredes) == 2, appears(Henson) == 3, appears(Lin) == 4))) ::: B) Geyer, Paredes, Henson, Lin
is_exception(is_sat(And(appears(Lin) == 1, appears(Henson) == 2, appears(Geyer) == 3, appears(Paredes) == 4))) ::: C) Lin, Henson, Geyer, Paredes
is_exception(is_sat(And(appears(Lin) == 1, appears(Paredes) == 2, appears(Henson) == 3, appears(Geyer) == 4))) ::: D) Lin, Paredes, Henson, Geyer
is_exception(is_sat(And(appears(Paredes) == 1, appears(Lin) == 2, appears(Henson) == 3, appears(Geyer) == 4))) ::: E) Paredes, Lin, Henson, Geyer
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly six actors—Geyer, Henson, Jhalani, Lin, Mitchell, and Paredes—will appear one after another in the opening credits of a television program. Their contracts contain certain restrictions that affect the order in which they can appear. Given these restrictions, the order in which the actors appear, from first to sixth, must conform to the following: Both Lin and Mitchell appear earlier than Henson. Both Lin and Paredes appear earlier than Jhalani. If Mitchell appears earlier than Paredes, then Henson appears earlier than Geyer. Geyer does not appear last.
Question:
If Jhalani appears earlier than Mitchell, then which one of the following could be the order in which the other four actors appear, from earliest to latest?
Choices:
(A) Geyer, Lin, Paredes, Henson
(B) Geyer, Paredes, Henson, Lin
(C) Lin, Henson, Geyer, Paredes
(D) Lin, Paredes, Henson, Geyer
(E) Paredes, Lin, Henson, Geyer
###"
"# Declarations
workers = EnumSort([Faith, Gus, Hannah, Juan, Kenneth, Lisa])
cars = EnumSort([car_1, car_2])
drives = Function([workers, cars] -> [bool])

# Constraints
ForAll([w:workers], Count([c:cars], drives(w, c)) == 1) ::: Each car must carry at least two of the workers
And(drives(Faith, car_1), drives(Hannah, car_1)) ::: Either Faith or Gus must drive the car in which Hannah travels
And(drives(Faith, car_2), drives(Hannah, car_2)) ::: Either Faith or Gus must drive the car in which Hannah travels
And(drives(Kenneth, car_1), drives(Juan, car_1)) ::: Either Faith or Kenneth must drive the car in which Juan travels
And(drives(Kenneth, car_2), drives(Juan, car_2)) ::: Either Faith or Kenneth must drive the car in which Juan travels
And(drives(Gus, car_1), drives(Lisa, car_1)) ::: Gus must travel in the same car as Lisa

# Options
Question ::: If Lisa drives one of the cars, then which one of the following could be true?
is_valid(Exists([w:workers], And(drives(w, car_1), drives(Kenneth, car_1)))) ::: (A)
is_valid(Exists([w:workers], And(drives(w, car_1), drives(Lisa, car_1)))) ::: (B)
is_valid(Exists([w:workers], And(drives(w, car_1), drives(Hannah, car_1)))) ::: (C)
is_valid(Exists([w:workers], And(drives(w, car_1), drives(Juan, car_1)))) ::: (D)
is_valid(Exists([w:workers], And(drives(w, car_1), drives(Hannah, car_1)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly six workers—Faith, Gus, Hannah, Juan, Kenneth, and Lisa—will travel to a business convention in two cars—car 1 and car 2. Each car must carry at least two of the workers, one of whom will be assigned to drive. For the entire trip, the workers will comply with an assignment that also meets the following constraints: Either Faith or Gus must drive the car in which Hannah travels. Either Faith or Kenneth must drive the car in which Juan travels. Gus must travel in the same car as Lisa.
Question:
If Lisa drives one of the cars, then which one of the following could be true?
Choices:
(A) Faith travels in the same car as Kenneth.
(B) Faith travels in the same car as Lisa.
(C) Gus travels in the same car as Hannah.
(D) Gus travels in the same car as Juan.
(E) Hannah travels in the same car as Lisa.
###"
"# Declarations
films = EnumSort([Fiesta, Glaciers, Hurricanes, Jets, Kangaroos, Lovebird])
released = Function([films] -> [int])
ForAll([f:films], And(1 <= released(f), released(f) <= 6))

# Constraints
Distinct([f:films], released(f)) ::: No two of these films can be released on the same date
And(released(Fiesta) < released(Jets), released(Fiesta) < released(Lovebird)) ::: Fiesta must be released earlier than both Jets and Lovebird
And(released(Kangaroos) < released(Jets), released(Jets) < released(Hurricanes)) ::: Kangaroos must be released earlier than Jets, and Jets must be released earlier than Hurricanes
released(Lovebird) < released(Glaciers) ::: Lovebird must be released earlier than Glaciers

# Options
Question ::: Which one of the following must be true?
is_valid(And(released(Fiesta) < released(Hurricanes), Not(released(Fiesta) == released(Hurricanes)))) ::: A) Fiesta is released earlier than Hurricanes.
is_valid(And(released(Jets) < released(Glaciers), Not(released(Jets) == released(Glaciers)))) ::: B) Jets is released earlier than Glaciers.
is_valid(And(released(Kangaroos) < released(Glaciers), Not(released(Kangaroos) == released(Glaciers)))) ::: C) Kangaroos is released earlier than Glaciers.
is_valid(And(released(Lovebird) < released(Hurricanes), Not(released(Lovebird) == released(Hurricanes)))) ::: D) Lovebird is released earlier than Hurricanes.
is_valid(And(released(Lovebird) < released(Jets), Not(released(Lovebird) == released(Jets)))) ::: E) Lovebird is------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A movie studio is scheduling the release of six films—Fiesta, Glaciers, Hurricanes, Jets, Kangaroos, and Lovebird. No two of these films can be released on the same date. The release schedule is governed by the following conditions: Fiesta must be released earlier than both Jets and Lovebird. Kangaroos must be released earlier than Jets, and Jets must be released earlier than Hurricanes. Lovebird must be released earlier than Glaciers.
Question:
Which one of the following must be true?
Choices:
(A) Fiesta is released earlier than Hurricanes.
(B) Jets is released earlier than Glaciers.
(C) Kangaroos is released earlier than Glaciers.
(D) Lovebird is released earlier than Hurricanes.
(E) Lovebird is released earlier than Jets.
###"
"# Declarations
birds = EnumSort([kingfishers, mynas, peacocks, robins, sparrows, woodpeckers])
in_sanctuary = Function([birds] -> [bool])

# Constraints
ForAll([b:birds], Count([b:birds], in_sanctuary(b)) >= 2) ::: A bird sanctuary contains birds of at least two of the following six kinds
And(in_sanctuary(woodpeckers), Not(in_sanctuary(mynas))) ::: Woodpeckers are not in the sanctuary if mynas are
And(in_sanctuary(peacocks), Not(in_sanctuary(robins))) ::: Peacocks are not in the sanctuary if robins are
Or(in_sanctuary(robins), in_sanctuary(woodpeckers)) ::: Either robins or woodpeckers, but not both, are in the sanctuary
And(in_sanctuary(woodpeckers), Or(in_sanctuary(kingfishers), in_sanctuary(sparrows), And(in_sanctuary(kingfishers), in_sanctuary(sparrows)))) ::: Woodpeckers are in the sanctuary if kingfishers, sparrows, or both are in the sanctuary

# Options
Question ::: If both kingfishers and sparrows are in the sanctuary, then each of the following could be true EXCEPT:
is_exception(is_sat(Count([b:birds], in_sanctuary(b)) == 3)) ::: A) Exactly three kinds of birds are in the sanctuary.
is_exception(is_sat(Count([b:birds], in_sanctuary(b)) == 4)) ::: B) Exactly four kinds of birds are in the sanctuary.
is_exception(is_sat(in_sanctuary(peacocks))) ::: C) There are peacocks in the sanctuary.
is_exception(is_sat(in_sanctuary(robins))) ::: D) There are robins in the sanctuary.
is_exception(is_sat(in_sanctuary(woodpeckers))) ::: E) There are woodpeckers in the sanctuary
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A bird sanctuary contains birds of at least two of the following six kinds—kingfishers, mynas, peacocks, robins, sparrows, and woodpeckers. No other kinds of birds are in the sanctuary. The following conditions must hold: Woodpeckers are not in the sanctuary if mynas are. Peacocks are not in the sanctuary if robins are. Either robins or woodpeckers, but not both, are in the sanctuary. Woodpeckers are in the sanctuary if kingfishers, sparrows, or both are in the sanctuary
Question:
If both kingfishers and sparrows are in the sanctuary, then each of the following could be true EXCEPT:
Choices:
(A) Exactly three kinds of birds are in the sanctuary.
(B) Exactly four kinds of birds are in the sanctuary.
(C) There are peacocks in the sanctuary.
(D) There are robins in the sanctuary.
(E) There are woodpeckers in the sanctuary
###"
"# Declarations
people = EnumSort([John, Kate, Lewis, Marie, Nat, Olive])
entrees = EnumSort([pork_chops, roast_beef, swordfish, tilefish, veal_cutlet])
orders = Function([people, entrees] -> [bool])

# Constraints
ForAll([p:people, e:entrees], And(orders(p, e), Not(orders(p, e)))) ::: The two people in each couple do not order the same kind of entree as each other
ForAll([p:people, e:entrees], Implies(And(p!= Nat, p!= John), orders(p, e))) ::: None of the men orders the same kind of entree as any of the other men
orders(Marie, swordfish) ::: Marie orders swordfish
ForAll([p:people, e:entrees], Implies(And(p!= John, p!= Nat), Not(orders(p, e)))) ::: Neither John nor Nat orders a fish entree
orders(Olive, roast_beef) ::: Olive orders roast beef

# Options
Question ::: If Lewis orders pork chops, then which one of the following is a complete and accurate list of the entrees any one of which John could order?
is_valid(Exists([e:entrees], And(orders(John, e), orders(Lewis, pork_chops)))) ::: (A)
is_valid(Exists([e:entrees], And(orders(John, e), orders(Lewis, pork_chops)))) ::: (B)
is_valid(Exists([e:entrees], And(orders(John, e), orders(Lewis, pork_chops)))) ::: (C)
is_valid(Exists([e:entrees], And(orders(John, e), orders(Lewis, pork_chops)))) ::: (D)
is_valid(Exists([e:entrees], And(orders(John, e), orders(Lewis, pork_chops)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.
Question:
If Lewis orders pork chops, then which one of the following is a complete and accurate list of the entrees any one of which John could order?
Choices:
(A) roast beef
(B) veal cutlet
(C) roast beef, veal cutlet
(D) roast beef, swordfish
(E) pork chops, roast beef, swordfish
###"
"# Declarations
houses = EnumSort([west, west_2, west_3, west_4, east_3, east_2, east])
families = EnumSort([Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans])
occupied = Function([houses, families] -> [bool])

# Constraints
ForAll([f:families], Count([h:houses], occupied(h, f)) == 1) ::: each house is occupied by exactly one of seven families
And(occupied(west, Rutans), Not(occupied(west_2, Rutans))) ::: The Rutans do not live in the first or the last house on the street
occupied(west_4, Kahns) ::: The Kahns live in the fourth house from the west end of the street
occupied(west_3, Muirs) ::: The Muirs live next to the Kahns
occupied(east_3, Piatts) ::: The Piatts live east of both the Kahns and the Muirs but west of the Lowes

# Options
Question ::: If the Owens live east of the Muirs, which one of the following statements must be true?
is_sat(occupied(west_4, Owens)) ::: (A)
is_sat(occupied(west_3, Owens)) ::: (B)
is_sat(occupied(east_3, Owens)) ::: (C)
is_sat(occupied(east_2, Owens)) ::: (D)
is_sat(occupied(east, Owens)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
There are exactly seven houses on a street. Each house is occupied by exactly one of seven families: the Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans. All the houses are on the same side of the street, which runs from west to east. The Rutans do not live in the first or the last house on the street. The Kahns live in the fourth house from the west end of the street. The Muirs live next to the Kahns. The Piatts live east of both the Kahns and the Muirs but west of the Lowes.
Question:
If the Owens live east of the Muirs, which one of the following statements must be true?
Choices:
(A) The Kahns live east of the Muirs.
(B) The Kahns live west of the Rutans.
(C) The Owens live west of the Lowes.
(D) The Owens live east of the Piatts.
(E) The Owens live west of the Piatts.
###"
"# Declarations
consumers = EnumSort([F, G, H, J, K, L, M, N])
groups = EnumSort([group_1, group_2])
assign = Function([consumers, groups] -> [bool])
ForAll([c:consumers], And(assign(c, group_1), assign(c, group_2))) ::: each person is assigned to exactly one of the two groups

# Constraints
assign(F, group_1) ::: F must be in the same group as J
assign(G, group_2) ::: G must be in a different group from M
And(assign(H, group_1), assign(L, group_1)) ::: If H is in group 1, then L must be in group 1
And(assign(N, group_2), assign(G, group_1)) ::: If N is in group 2, then G must be in group 1

# Options
Question ::: Group 1 could consist of
is_valid(And(assign(F, group_1), assign(G, group_2), assign(H, group_1), assign(J, group_1))) ::: (A)
is_valid(And(assign(F, group_1), assign(H, group_1), assign(L, group_1), assign(M, group_2))) ::: (B)
is_valid(And(assign(F, group_1), assign(J, group_1), assign(K, group_1), assign(L, group_1))) ::: (C)
is_valid(And(assign(G, group_1), assign(H, group_1), assign(L, group_1), assign(N, group_2))) ::: (D)
is_valid(And(assign(G, group_1), assign(K, group_1), assign(M, group_1), assign(N, group_2))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.
Question:
Group 1 could consist of
Choices:
(A) F, G, H, and J
(B) F, H, L, and M
(C) F, J, K, and L
(D) G, H, L, and N
(E) G, K, M, and N
###"
"# Declarations
houses = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
styles = EnumSort([ranch, split_level, Tudor])
builds = Function([houses] -> [styles])

# Constraints
ForAll([h:houses], And(builds(h) == ranch, builds(h + 1) == Tudor)) ::: Adjacent houses are of different styles
ForAll([h:houses], And(builds(h) == split_level, builds(h + 1)!= split_level)) ::: No split-level house faces another split-level house
ForAll([h:houses], And(builds(h) == ranch, Count([h:houses], builds(h) == Tudor) >= 1)) ::: Every ranch house has at least one Tudor house adjacent to it
builds(3) == ranch ::: House 3 is a ranch house
builds(6) == split_level ::: House 6 is a split-level house

# Options
Question ::: On the street, there could be exactly
is_valid(Count([h:houses], builds(h) == ranch) == 1) ::: (A)
is_valid(Count([h:houses], builds(h) == Tudor) == 1) ::: (B)
is_valid(Count([h:houses], builds(h) == Tudor) == 2) ::: (C)
is_valid(Count([h:houses], builds(h) == ranch) == 4) ::: (D)
is_valid(Count([h:houses], builds(h) == ranch) == 5) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.
Question:
On the street, there could be exactly
Choices:
(A) one ranch house
(B) one Tudor house
(C) two Tudor houses
(D) four ranch houses
(E) five ranch houses
###"
"# Declarations
department = EnumSort([F, G, Q, R, S, V, W])
rooms = EnumSort([101, 102, 103, 104, 105, 106, 107])
assign = Function([department, rooms] -> [bool])

# Constraints
ForAll([m:department], And(assign(m, 101), assign(m, 107))) ::: Neither professor is assigned room 101 and neither professor is assigned room 107
ForAll([m:department], Not(assign(m, 101), assign(m, 107))) ::: Neither instructor is assigned a room next to a professor's room
ForAll([m:department], Not(assign(m, 101), assign(m, 107))) ::: Neither professor is assigned room 101 and neither professor is assigned room 107
ForAll([m:department], Not(assign(G, 102), assign(R, 102))) ::: G is not assigned a room next to R's room
ForAll([m:department], Not(assign(W, 103), assign(V, 103))) ::: W is not assigned a room next to V's room unless R is also assigned a room next to V's room

# Options
Question ::: What is the greatest number of rooms that could be between the rooms to which F and G are assigned?
is_valid(Count([r:rooms], And(assign(F, r), assign(G, r))) == 1) ::: (A)
is_valid(Count([r:rooms], And(assign(F, r), assign(G, r))) == 2) ::: (B)
is_valid(Count([r:rooms], And(assign(F, r), assign(G, r))) == 3) ::: (C)
is_valid(Count([r:rooms], And(assign(F, r), assign(G, r))) == 4) ::: (D)
is_valid(Count([r:rooms], And(assign(F, r), assign(G, r))) == 5) :::------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.
Question:
What is the greatest number of rooms that could be between the rooms to which F and G are assigned?
Choices:
(A) one
(B) two
(C) three
(D) four
(E) five
###"
"# Declarations
rugs = EnumSort([oval_wool, rectangular_wool, oval_silk, rectangular_silk])
selected = Function([rugs] -> [bool])
ForAll([r:rugs], And(1 <= Count([r:rugs], selected(r)), Count([r:rugs], selected(r)) <= 6))

# Constraints
And(Count([r:rugs], selected(r)) >= 2, Count([r:rugs], selected(r)) <= 3) ::: The number of wool rugs selected can be neither less than two nor more than three
And(selected(oval_silk), Count([r:rugs], selected(r)) >= 2) ::: If the oval silk rug is selected, at least one rectangular silk rug must be selected

# Options
Question ::: If only one silk rug is selected for the exhibition, then the other rugs selected must be a group made up of
is_sat(And(selected(oval_wool), selected(rectangular_wool), Not(selected(oval_silk)), Not(selected(rectangular_silk)))) ::: (A)
is_sat(And(selected(oval_wool), selected(oval_silk), Not(selected(rectangular_wool)), Not(selected(rectangular_silk)))) ::: (B)
is_sat(And(selected(oval_wool), selected(oval_silk), selected(rectangular_silk), Not(selected(rectangular_wool)))) ::: (C)
is_sat(And(selected(oval_wool), selected(oval_silk), selected(rectangular_silk), selected(rectangular_wool))) ::: (D)
is_sat(And(selected(rectangular_wool), selected(rectangular_silk), Not(selected(oval_wool)), Not(selected(oval_silk)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.
Question:
If only one silk rug is selected for the exhibition, then the other rugs selected must be a group made up of
Choices:
(A) one oval rug and two rectangular rugs
(B) two oval rugs and one rectangular rug
(C) two oval rugs and two rectangular rugs
(D) two oval rugs and three rectangular rugs
(E) three rectangular rugs
###"
"# Declarations
travelers = EnumSort([Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, Underwood])
seats = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
seated = Function([travelers, seats] -> [bool])
ForAll([t:travelers], And(seated(t, 1), seated(t, 2), seated(t, 3), seated(t, 4), seated(t, 5), seated(t, 6), seated(t, 7), seated(t, 8), seated(t, 9)))

# Constraints
seated(Oribe, 9) ::: Oribe's seat is in the last row
And(seated(Paulsen, 5), seated(Rosen, 5), seated(Paulsen, 6), seated(Rosen, 6)) ::: Paulsen's seat is immediately beside Rosen's seat and also immediately beside an unassigned seat
And(seated(Rosen, 7), seated(Norris, 4), seated(Rosen, 6)) ::: Rosen's seat is in the row immediately behind the row in which Norris' seat is located
Not(And(seated(Semonelli, 4), seated(Underwood, 4))) ::: Neither Semonelli nor Underwood is seated immediately beside Norris

# Options
Question ::: If the seat to which Tan is assigned is immediately beside a seat assigned to another traveler and also immediately beside one of the unassigned seats, which one of the following must be true?
is_sat(And(seated(Tan, 1), seated(Tan, 2), seated(Tan, 3), seated(Tan, 4), seated(Tan, 5), seated(Tan, 6), seated(Tan, 7), seated(Tan, 8), seated(Tan, 9))) ::: (A)
is_sat(And(seated(Tan, 1), seated(Tan, 2), seated(Tan, 3), seated(Tan, 4), seated(Tan, 5), seated(Tan, 6), seated(Tan, 7), seated(Tan, 8), seated(Tan, 9))) ::: (B)
is_sat(And(seated(Oribe, 1), seated(Oribe, 2), seated(Oribe, 3), seated(Oribe, 4), seated(Oribe, 5), seated(Oribe, 6), seated(Oribe, 7), seated(Oribe, 8), seated(Oribe, 9))) ::: (C)
is_sat(And(seated(Oribe, 1), seated(Oribe, 2), seated(Oribe, 3), seated(Oribe, 4), seated(Oribe, 5), seated(Oribe, 6), seated(Oribe, 7), seated(Oribe, 8), seated(Oribe, 9))) ::: (D)
is_sat(And(seated(Semonelli, 1), seated(Semonelli, 2), seated(Semonelli, 3), seated(Semonelli, 4), seated(Semonelli, 5), seated(Semonelli, 6), seated(Semonelli, 7), seated(Semonelli, 8), seated(Semonelli, 9))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Each of seven travelers—Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, and Underwood—will be assigned to exactly one of nine airplane seats. The seats are numbered from 1 through 9 and arranged in rows as follows: Front row: 1 2 3 Middle row: 4 5 6 Last row: 7 8 9 Only seats in the same row as each other are immediately beside each other. Seat assignments must meet the following conditions: Oribe's seat is in the last row. Paulsen's seat is immediately beside Rosen's seat and also immediately beside an unassigned seat. Rosen's seat is in the row immediately behind the row in which Norris' seat is located. Neither Semonelli nor Underwood is seated immediately beside Norris.
Question:
If the seat to which Tan is assigned is immediately beside a seat assigned to another traveler and also immediately beside one of the unassigned seats, which one of the following must be true?
Choices:
(A) Tan is assigned to a seat in the front row.
(B) Tan is assigned to a seat in the last row.
(C) Oribe is assigned to a seat immediately beside Semonelli.
(D) Oribe is assigned to a seat immediately beside Tan.
(E) Semonelli is assigned to a seat immediately beside Underwood.
###"
"# Declarations
persons = EnumSort([G, H, I, K, L, M, P])
teams = EnumSort([team1, team2, team3])
organizer = Function([persons] -> [bool])
teammate = Function([persons, teams] -> [bool])

# Constraints
ForAll([p:persons], And(organizer(p) == False, teammate(p, team1) == False, teammate(p, team2) == False, teammate(p, team3) == False)) ::: one person will be the organizer and not a member of any team
And(teammate(M, team1), teammate(P, team1)) ::: M and P cannot be on the same team as each other
And(teammate(K, team1), teammate(M, team1)) ::: If K is on a team, M must also be on that team
And(teammate(G, team1), Or(teammate(H, team1), teammate(I, team1))) ::: If G is on a team, either H or I must also be on that team
And(teammate(H, team1), organizer(H)) ::: If H is on a team, K must be the organizer

# Options
Question ::: Each of the following is a pair of persons who can constitute a team EXCEPT:
is_exception(is_sat(teammate(H, team1) == teammate(I, team1))) ::: (A)
is_exception(is_sat(teammate(H, team1) == teammate(M, team1))) ::: (B)
is_exception(is_sat(teammate(I, team1) == teammate(M, team1))) ::: (C)
is_exception(is_sat(teammate(I, team1) == teammate(P, team1))) ::: (D)
is_exception(is_sat(teammate(L, team1) == teammate(P, team1))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Seven persons—G, H, I, K, L, M, and P—are going rock-climbing together. One person will be the organizer and not a member of any team. The remaining six will form three climbing teams, each consisting of two persons. No person can be on more than one team. The following conditions also apply: M and P cannot be on the same team as each other. If K is on a team, M must also be on that team. If G is on a team, either H or I must also be on that team. If H is on a team, K must be the organizer.
Question:
Each of the following is a pair of persons who can constitute a team EXCEPT:
Choices:
(A) H, I
(B) H, M
(C) I, M
(D) I, P
(E) L, P
###"
"# Declarations
singers = EnumSort([Jamie, Ken, Lalitha, Maya, Norton, Olive, Patrick])
performances = EnumSort([first, second, third, fourth, fifth, sixth])
scheduled = Function([singers, performances] -> [bool])

# Constraints
ForAll([s:singers], And(scheduled(s, first), Not(scheduled(s, second)))) ::: each singer, performing alone, will give exactly one performance
And(scheduled(Ken, first), scheduled(Jamie, second)) ::: Jamie performs immediately after Ken
And(scheduled(Patrick, second), Not(scheduled(Maya, second))) ::: Patrick performs at some time after Maya
And(scheduled(Lalitha, third), scheduled(Norton, fifth)) ::: Lalitha performs third only if Norton performs fifth
And(scheduled(Patrick, fifth), Not(scheduled(Patrick, second))) ::: If Patrick does not perform second, he performs fifth

# Options
Question ::: If Jamie's performance is scheduled to be immediately before Lalitha's performance, Jamie's performance CANNOT be scheduled to be
is_exception(is_sat(scheduled(Jamie, second))) ::: (A)
is_exception(is_sat(scheduled(Jamie, third))) ::: (B)
is_exception(is_sat(scheduled(Jamie, fourth))) ::: (C)
is_exception(is_sat(scheduled(Jamie, fifth))) ::: (D)
is_exception(is_sat(scheduled(Jamie, sixth))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.
Question:
If Jamie's performance is scheduled to be immediately before Lalitha's performance, Jamie's performance CANNOT be scheduled to be
Choices:
(A) second
(B) third
(C) fourth
(D) fifth
(E) sixth
###"
"# Declarations
students = EnumSort([Frank, Gwen, Henry, Joan, Victor, Wanda, Xavier, Yvette])
benches = EnumSort([1, 2, 3, 4])
assignments = Function([students, benches] -> [bool])

# Constraints
ForAll([s:students], Count([b:benches], assignments(s, b)) == 1) ::: each student is assigned to exactly one bench
ForAll([b:benches], Count([s:students], assignments(s, b)) == 2) ::: exactly two students are assigned to each bench
ForAll([s:students], And(assignments(s, 1), assignments(s, 2))) ::: exactly one major is assigned to each bench
And(assignments(Frank, 1), assignments(Frank, 2)) ::: Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench
And(assignments(Frank, 1), assignments(Victor, 1)) ::: Frank is assigned to the same bench as Victor
And(assignments(Gwen, 1), Not(assignments(Wanda, 1))) ::: Gwen is not assigned to the same bench as Wanda

# Options
Question ::: If Wanda is assigned to a lower-numbered bench than is Joan, then Henry must be assigned to a
is_valid(And(assignments(Wanda, 1), assignments(Henry, 2))) ::: (A)
is_valid(And(assignments(Wanda, 1), assignments(Henry, 3))) ::: (B)
is_valid(And(assignments(Wanda, 1), assignments(Henry, 4))) ::: (C)
is_valid(And(assignments(Wanda, 2), assignments(Henry, 1))) ::: (D)
is_valid(And(assignments(Wanda, 2), assignments(Henry, 3))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.
Question:
If Wanda is assigned to a lower-numbered bench than is Joan, then Henry must be assigned to a
Choices:
(A) lower-numbered bench than is Frank
(B) lower-numbered bench than is Gwen
(C) lower-numbered bench than is Xavier
(D) higher-numbered bench than is Victor
(E) higher-numbered bench than is Yvette
###"
"# Declarations
packages = EnumSort([L, M, N, O, P, S, T])
delivered = Function([packages] -> [int])
ForAll([p:packages], And(1 <= delivered(p), delivered(p) <= 7))

# Constraints
Distinct([p:packages], delivered(p)) ::: no two packages are delivered at the same time
And(delivered(P) == 1, delivered(P) == 7) ::: P is delivered either first or seventh
And(delivered(N) > delivered(L), delivered(N) <= delivered(O)) ::: The messenger delivers N at some time after delivering L
And(delivered(T) > delivered(M), delivered(T) <= delivered(P)) ::: The messenger delivers T at some time after delivering M
And(delivered(O) - delivered(L) == 1, delivered(O) - delivered(L) == 0) ::: The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O
And(delivered(P) - delivered(M) == 1, delivered(P) - delivered(M) == 0) ::: The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P

# Options
Question ::: If the messenger delivers M at some time after delivering O, the fifth package delivered could be any one of the following EXCEPT:
is_exception(is_sat(delivered(M) == 5)) ::: (A)
is_exception(is_sat(delivered(M) == 5)) ::: (B)
is_exception(is_sat(delivered(N) == 5)) ::: (C)
is_exception(is_sat(delivered(S) == 5)) ::: (D)
is_exception(is_sat(delivered(T) == 5)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.
Question:
If the messenger delivers M at some time after delivering O, the fifth package delivered could be any one of the following EXCEPT:
Choices:
(A) L
(B) M
(C) N
(D) S
(E) T
###"
"# Declarations
cars = EnumSort([car1, car2, car3, car4, car5, car6])
colors = EnumSort([green, orange, purple])
colors_of_cars = Function([cars] -> [colors])

# Constraints
ForAll([c:cars], colors_of_cars(c)!= green) ::: No car can be the same color as any car next to it in line
ForAll([c:cars], colors_of_cars(c)!= orange) ::: No car can be the same color as any car next to it in line
ForAll([c:cars], colors_of_cars(c)!= purple) ::: No car can be the same color as any car next to it in line
colors_of_cars(car5) == purple ::: Either car 5 or car 6 must be purple
colors_of_cars(car1)!= orange ::: Car 1 cannot be orange
colors_of_cars(car4)!= green ::: Car 4 cannot be green

# Options
Question ::: The cars in which one of the following pairs CANNOT be the same color as each other?
is_valid(colors_of_cars(car1)!= colors_of_cars(car4)) ::: (A)
is_valid(colors_of_cars(car1)!= colors_of_cars(car5)) ::: (B)
is_valid(colors_of_cars(car3)!= colors_of_cars(car5)) ::: (C)
is_valid(colors_of_cars(car3)!= colors_of_cars(car6)) ::: (D)
is_valid(colors_of_cars(car4)!= colors_of_cars(car6)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Six cars are to be arranged in a straight line, and will be numbered 1 through 6, in order, from the front of the line to the back of the line. Each car is exactly one color: two are green, two are orange, and two are purple. The arrangement of cars is restricted as follows: No car can be the same color as any car next to it in line. Either car 5 or car 6 must be purple. Car 1 cannot be orange. Car 4 cannot be green.
Question:
The cars in which one of the following pairs CANNOT be the same color as each other?
Choices:
(A) cars 1 and 4
(B) cars 1 and 5
(C) cars 3 and 5
(D) cars 3 and 6
(E) cars 4 and 6
###"
"# Declarations
clowns = EnumSort([Q, R, S, T, V, W, Y, Z])
gets_out = Function([clowns] -> [int])
ForAll([c:clowns], And(1 <= gets_out(c), gets_out(c) <= 8))

# Constraints
Distinct([c:clowns], gets_out(c)) ::: no two clowns get out at the same time
And(gets_out(V) < gets_out(Y), gets_out(V) < gets_out(Q)) ::: V gets out at some time before both Y and Q
And(gets_out(Q) > gets_out(Z), gets_out(Q) <= 8) ::: Q gets out at some time after Z
And(gets_out(T) < gets_out(V), gets_out(T) > gets_out(R)) ::: T gets out at some time before V but at some time after R
And(gets_out(S) > gets_out(V), gets_out(S) <= 8) ::: S gets out at some time after V
And(gets_out(R) < gets_out(W), gets_out(R) <= 8) ::: R gets out at some time before W

# Options
Question ::: Which one of the following could be the order, from first to last, in which the clowns get out of the car?
is_sat(And(gets_out(T) == 1, gets_out(Z) == 2, gets_out(V) == 3, gets_out(R) == 4, gets_out(W) == 5, gets_out(Y) == 6, gets_out(S) == 7, gets_out(Q) == 8)) ::: (A)
is_sat(And(gets_out(Z) == 1, gets_out(R) == 2, gets_out(W) == 3, gets_out(Q) == 4, gets_out(T) == 5, gets_out(V) == 6, gets_out(Y) == 7, gets_out(S) == 8)) ::: (B)
is_sat(And(gets_out(R) == 1, gets_out(W) == 2, gets_out(T) == 3, gets_out(V) == 4, gets_out(Q) == 5, gets_out(Z) == 6, gets_out(S) == 7, gets_out(Y) == 8)) ::: (C)
is_sat(And(gets_out(Z) == 1, gets_out(W) == 2, gets_out(R) == 3, gets_out(T) == 4, gets_out(V) == 5, gets_out(Y) == 6, gets_out(Q) == 7, gets_out(S) == 8)) ::: (D)
is_sat(And(gets_out(R) == 1, gets_out(W) == 2, gets_out(T) == 3, gets_out(V) == 4, gets_out(Z) == 5, gets_out(S) == 6, gets_out(Y) == 7, gets_out(Q) == 8)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.
Question:
Which one of the following could be the order, from first to last, in which the clowns get out of the car?
Choices:
(A) T, Z, V, R, W, Y, S, Q
(B) Z, R, W, Q, T, V, Y, S
(C) R, W, T, V, Q, Z, S, Y
(D) Z, W, R, T, V, Y, Q, S
(E) R, W, T, V, Z, S, Y, Q
###"
"# Declarations
medications = EnumSort([F, G, H, I, K, L, M])
ranks = Function([medications] -> [int])
ForAll([m:medications], And(1 <= ranks(m), ranks(m) <= 5))

# Constraints
ranks(L) == 2 ::: L ranks second
Or(ranks(F) == 1, ranks(G) == 1) ::: Either F or G ranks first
ranks(I) == 1 ::: I is tested
ranks(H) > ranks(G) ::: H ranks better than G if both are tested
ranks(K) > ranks(F) ::: K ranks better than F if both are tested
Implies(ranks(M) == 1, And(ranks(F) == 1, ranks(H) == 1)) ::: If M is tested, both F and H are also tested

# Options
Question ::: Which one of the following cold medications must be among those tested in the study?
is_valid(Exists([m:medications], ranks(m) == 1)) ::: (A)
is_valid(Exists([m:medications], ranks(m) == 2)) ::: (B)
is_valid(Exists([m:medications], ranks(m) == 3)) ::: (C)
is_valid(Exists([m:medications], ranks(m) == 4)) ::: (D)
is_valid(Exists([m:medications], ranks(m) == 5)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A study sponsored by a consumer group tests exactly five of seven cold medications—F, G, H, I, K, L, and M—and ranks the medications tested from first (best) to fifth (worst). There are no ties. The following conditions must apply: L ranks second. Either F or G ranks first. I is tested. H ranks better than G if both are tested. K ranks better than F if both are tested. If M is tested, both F and H are also tested.
Question:
Which one of the following cold medications must be among those tested in the study?
Choices:
(A) F
(B) G
(C) H
(D) K
(E) M
###"
"# Declarations
animals = EnumSort([F, G, H, K, L, N, T, V, Z])
selected = Function([animals] -> [bool])
ForAll([a:animals], And(1 <= selected(a), selected(a) <= 6))

# Constraints
Not(And(selected(F), selected(H))) ::: F and H are not both selected
Not(And(selected(N), selected(T))) ::: N and T are not both selected
Implies(selected(H), selected(K)) ::: If H is selected, K is also selected
Implies(selected(K), selected(N)) ::: If K is selected, N is also selected

# Options
Question ::: If T is selected, which one of the following is a pair of animals that must be among the animals selected?
is_sat(And(selected(T), selected(F))) ::: (A)
is_sat(And(selected(T), selected(G))) ::: (B)
is_sat(And(selected(T), selected(K))) ::: (C)
is_sat(And(selected(T), selected(L))) ::: (D)
is_sat(And(selected(T), selected(N))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.
Question:
If T is selected, which one of the following is a pair of animals that must be among the animals selected?
Choices:
(A) F and G
(B) G and H
(C) K and L
(D) K and Z
(E) L and N
###"
"# Declarations
dignitaries = EnumSort([Fuentes, Matsuba, Rhee, Soleimani, Tbahi])
meetings = EnumSort([1, 2, 3, 4, 5, 6, 7])
meets = Function([dignitaries, meetings] -> [bool])

# Constraints
Count([d:dignitaries], meets(d, 1)) == 3 ::: She has exactly three meetings with Fuentes, and exactly one with each of the other dignitaries
ForAll([d:dignitaries], And(meets(d, 1), Not(meets(d, 2)))) ::: She does not have any meetings in a row with Fuentes
meets(Soleimani, 2) ::: Her meeting with Soleimani is the very next one after her meeting with Tbahi
Not(meets(Matsuba, 1)) ::: Neither the first nor last of her meetings is with Matsuba

# Options
Question ::: If Garibaldi's meeting with Matsuba is the very next meeting after Garibaldi's meeting with Rhee, then with which one of the following dignitaries must Garibaldi's fourth meeting be?
is_valid(meets(Fuentes, 4)) ::: (A)
is_valid(meets(Matsuba, 4)) ::: (B)
is_valid(meets(Rhee, 4)) ::: (C)
is_valid(meets(Soleimani, 4)) ::: (D)
is_valid(meets(Tbahi, 4)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
In the course of one month Garibaldi has exactly seven different meetings. Each of her meetings is with exactly one of five foreign dignitaries: Fuentes, Matsuba, Rhee, Soleimani, or Tbahi. The following constraints govern Garibaldi's meetings: She has exactly three meetings with Fuentes, and exactly one with each of the other dignitaries. She does not have any meetings in a row with Fuentes. Her meeting with Soleimani is the very next one after her meeting with Tbahi. Neither the first nor last of her meetings is with Matsuba.
Question:
If Garibaldi's meeting with Matsuba is the very next meeting after Garibaldi's meeting with Rhee, then with which one of the following dignitaries must Garibaldi's fourth meeting be?
Choices:
(A) Fuentes
(B) Matsuba
(C) Rhee
(D) Soleimani
(E) Tbahi
###"
"# Declarations
people = EnumSort([Lulu, Nam, Ofelia, Pachai, Santiago, Tyrone])
games = EnumSort([first, second, third, fourth])
plays = Function([people, games] -> [bool])

# Constraints
ForAll([p:people], Count([g:games], plays(p, g)) >= 1) ::: each person plays in at least one game
And(Not(plays(Tyrone, first)), Not(plays(Tyrone, third))) ::: Tyrone does not play in the first or third game
plays(Lulu, fourth) ::: Lulu plays in the last game
And(plays(Nam, first), Not(plays(Nam, second)), Not(plays(Nam, third)), Not(plays(Nam, fourth))) ::: Nam plays in only one game and it is not against Pachai
And(plays(Santiago, second), plays(Santiago, fourth), Not(plays(Santiago, third)), Not(plays(Santiago, first))) ::: Santiago plays in exactly two games, one just before and one just after the only game that Ofelia plays in

# Options
Question ::: ::: Which one of the following contestants could play in two consecutive games?
is_sat(And(plays(p, second), plays(p, third))) ::: (A)
is_sat(And(plays(p, first), plays(p, second))) ::: (B)
is_sat(And(plays(p, second), plays(p, fourth))) ::: (C)
is_sat(And(plays(p, third), plays(p, fourth))) ::: (D)
is_sat(And(plays(p, first), plays(p, third))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly six people—Lulu, Nam, Ofelia, Pachai, Santiago, and Tyrone—are the only contestants in a chess tournament. The tournament consists of four games, played one after the other. Exactly two people play in each game, and each person plays in at least one game. The following conditions must apply: Tyrone does not play in the first or third game. Lulu plays in the last game. Nam plays in only one game and it is not against Pachai. Santiago plays in exactly two games, one just before and one just after the only game that Ofelia plays in.
Question:
Which one of the following contestants could play in two consecutive games?
Choices:
(A) Lulu
(B) Nam
(C) Ofelia
(D) Santiago
(E) Tyrone
###"
"# Declarations
suites = EnumSort([F, G, H, J, K, L])
expensive = Function([suites] -> [bool])
ForAll([s:suites], expensive(s))

# Constraints
And(expensive(H), Not(expensive(L))) ::: H is more expensive than L
And(expensive(G), Not(expensive(K)), Not(expensive(L))) ::: If G is more expensive than H, then neither K nor L is more expensive than J
And(expensive(H), Not(expensive(G)), Not(expensive(J)), Not(expensive(L))) ::: If H is more expensive than G, then neither J nor L is more expensive than K
Or(expensive(F), expensive(H), Not(expensive(G))) ::: F is more expensive than G, or else F is more expensive than H, but not both

# Options
Question ::: Which one of the following CANNOT be the most expensive suite?
is_exception(is_sat(expensive(F))) ::: (A)
is_exception(is_sat(expensive(G))) ::: (B)
is_exception(is_sat(expensive(H))) ::: (C)
is_exception(is_sat(expensive(J))) ::: (D)
is_exception(is_sat(expensive(K))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Six hotel suites—F, G, H, J, K, L—are ranked from most expensive (first) to least expensive (sixth). There are no ties. The ranking must be consistent with the following conditions: H is more expensive than L. If G is more expensive than H, then neither K nor L is more expensive than J. If H is more expensive than G, then neither J nor L is more expensive than K. F is more expensive than G, or else F is more expensive than H, but not both.
Question:
Which one of the following CANNOT be the most expensive suite?
Choices:
(A) F
(B) G
(C) H
(D) J
(E) K
###"
"# Declarations
parcels = EnumSort([G, H, J, K, L, M, N, O])
delivered = Function([parcels] -> [int])
ForAll([p:parcels], And(1 <= delivered(p), delivered(p) <= 8))

# Constraints
Distinct([p:parcels], delivered(p)) ::: no two parcels are delivered at the same time
And(delivered(L) > delivered(H), delivered(K) < delivered(O)) ::: L is delivered later than H. K is delivered earlier than O.
And(delivered(H) < delivered(M), delivered(O) > delivered(G)) ::: H is delivered earlier than M. O is delivered later than G.
And(delivered(M) < delivered(G), delivered(N) < delivered(M), delivered(J) < delivered(M)) ::: M is delivered earlier than G. Both N and J are delivered earlier than M.

# Options
Question ::: Each of the following could be true EXCEPT:
is_exception(is_sat(delivered(H) > delivered(K))) ::: (A)
is_exception(is_sat(delivered(J) > delivered(G))) ::: (B)
is_exception(is_sat(delivered(L) > delivered(O))) ::: (C)
is_exception(is_sat(delivered(M) > delivered(L))) ::: (D)
is_exception(is_sat(delivered(N) > delivered(H))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A courier delivers exactly eight parcels—G, H, J, K, L, M, N, and O. No two parcels are delivered at the same time, nor is any parcel delivered more than once. The following conditions must apply: L is delivered later than H. K is delivered earlier than O. H is delivered earlier than M. O is delivered later than G. M is delivered earlier than G. Both N and J are delivered earlier than M.
Question:
Each of the following could be true EXCEPT:
Choices:
(A) H is delivered later than K.
(B) J is delivered later than G.
(C) L is delivered later than O.
(D) M is delivered later than L.
(E) N is delivered later than H.
###"
"# Declarations
recycling_centers = EnumSort([Center_1, Center_2, Center_3])
materials = EnumSort([glass, newsprint, plastic, tin, wood])
recycles = Function([recycling_centers, materials] -> [bool])

# Constraints
ForAll([c:recycling_centers], Count([m:materials], recycles(c, m)) >= 2) ::: Each recycling center recycles at least two but no more than three of these kinds of material
ForAll([c:recycling_centers], Count([m:materials], recycles(c, m)) <= 3)
ForAll([m:materials], Implies(recycles(Center_1, m), recycles(Center_2, m))) ::: Every kind of material that Center 2 recycles is also recycled at Center 1
ForAll([m:materials], Implies(recycles(Center_2, m), recycles(Center_1, m)))
ForAll([m:materials], Implies(recycles(Center_1, m), Not(recycles(Center_3, m)))) ::: Only one of the recycling centers recycles plastic, and that recycling center does not recycle glass
ForAll([m:materials], Implies(recycles(Center_3, m), Not(recycles(Center_1, m))))
ForAll([m:materials], Implies(recycles(Center_1, wood), recycles(Center_1, newsprint))) ::: Any recycling center that recycles wood also recycles newsprint

# Options
Question ::: If Center 1 is the only recycling center that recycles wood, then which one of the following could be a complete and accurate list of the kinds of material that one of the recycling centers recycles?
is_sat(And(recycles(Center_1, wood), recycles(Center_1, plastic), Not(recycles(Center_1, glass)))) ::: (A)
is_sat(And(recycles(Center_1, wood), recycles(Center_1, newsprint), Not(recycles(Center_1, glass)))) ::: (B)
is_sat(And(recycles(Center_1, wood), recycles(Center_1, newsprint), Not(recycles(Center_1, tin)))) ::: (C)
is_sat(And(recycles(Center_1, wood), recycles(Center_1, glass), Not(recycles(Center_1, tin)))) ::: (D)
is_sat(And(recycles(Center_1, wood), recycles(Center_1, glass), Not(recycles(Center_1, plastic)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
There are exactly three recycling centers in Rivertown: Center 1, Center 2, and Center 3. Exactly five kinds of material are recycled at these recycling centers: glass, newsprint, plastic, tin, and wood. Each recycling center recycles at least two but no more than three of these kinds of material. The following conditions must hold: Any recycling center that recycles wood also recycles newsprint. Every kind of material that Center 2 recycles is also recycled at Center 1. Only one of the recycling centers recycles plastic, and that recycling center does not recycle glass.
Question:
If Center 1 is the only recycling center that recycles wood, then which one of the following could be a complete and accurate list of the kinds of material that one of the recycling centers recycles?
Choices:
(A) plastic, tin
(B) newsprint, wood
(C) newsprint, tin
(D) glass, wood
(E) glass, tin
###"
"# Declarations
architects = EnumSort([Green, Jackson, Liu, Mertz, Peete, Valdez])
designs = EnumSort([d1, d2, d3, d4, d5, d6])
presented = Function([architects, designs] -> [bool])
ForAll([a:architects], Count([d:designs], presented(a, d)) == 1)
ForAll([d:designs], Count([a:architects], presented(a, d)) == 1)

# Constraints
And(presented(Mertz, d1), presented(Liu, d2), presented(Peete, d3)) ::: Mertz's design is presented at some time before Liu's and after Peete's
Or(And(presented(Green, d1), Not(presented(Jackson, d2))), And(presented(Liu, d2), Not(presented(Green, d1)))) ::: Green's design is presented either at some time before Jackson's or at some time after Liu's, but not both
Or(And(presented(Valdez, d1), Not(presented(Green, d2))), And(presented(Peete, d2), Not(presented(Valdez, d1)))) ::: Valdez's design is presented either at some time before Green's or at some time after Peete's, but not both

# Options
Question ::: Mertz's design CANNOT be presented
is_sat(Not(presented(Mertz, d6))) ::: (A)
is_sat(Not(presented(Mertz, d5))) ::: (B)
is_sat(Not(presented(Mertz, d4))) ::: (C)
is_sat(Not(presented(Mertz, d3))) ::: (D)
is_sat(Not(presented(Mertz, d2))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A competition is being held to select a design for Yancy College's new student union building. Each of six architects—Green, Jackson, Liu, Mertz, Peete, and Valdez—has submitted exactly one design. There are exactly six designs, and they are presented one at a time to the panel of judges, each design being presented exactly once, consistent with the following conditions: Mertz's design is presented at some time before Liu's and after Peete's. Green's design is presented either at some time before Jackson's or at some time after Liu's, but not both. Valdez's design is presented either at some time before Green's or at some time after Peete's, but not both.
Question:
Mertz's design CANNOT be presented
Choices:
(A) sixth
(B) fifth
(C) fourth
(D) third
(E) second
###"
"# Declarations
parks = EnumSort([Graystone_Park, Landing_Park])
trees = EnumSort([maples, oaks, sycamores, tamaracks])
planted = Function([parks, trees] -> [bool])

# Constraints
ForAll([p:parks], Count([t:trees], planted(p, t)) == 3) ::: Each of the parks is planted with exactly three of the varieties
And(planted(Graystone_Park, maples), planted(Landing_Park, sycamores)) ::: At least one of the parks is planted with both maples and sycamores
ForAll([p:parks], Implies(planted(p, oaks), planted(p, tamaracks))) ::: Any park that is planted with oaks will also be planted with tamaracks
planted(Graystone_Park, maples) ::: Graystone Park is planted with maples

# Options
Question ::: If both parks are planted with sycamores, which one of the following could be true?
is_sat(Count([p:parks], planted(p, maples)) == Count([p:parks], planted(p, oaks))) ::: (A)
is_sat(Count([p:parks], planted(p, maples)) > Count([p:parks], planted(p, sycamores))) ::: (B)
is_sat(Count([p:parks], planted(p, oaks)) == Count([p:parks], planted(p, sycamores))) ::: (C)
is_sat(planted(Graystone_Park, maples) == planted(Graystone_Park, oaks)) ::: (D)
is_sat(planted(Landing_Park, maples) == planted(Landing_Park, oaks)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A town has exactly two public parks—Graystone Park and Landing Park—which are to be planted with North American trees. There are exactly four varieties of trees available—maples, oaks, sycamores, and tamaracks. The planting of the trees must be in accord with the following: Each of the parks is planted with exactly three of the varieties. At least one of the parks is planted with both maples and sycamores. Any park that is planted with oaks will also be planted with tamaracks. Graystone Park is planted with maples.
Question:
If both parks are planted with sycamores, which one of the following could be true?
Choices:
(A) The number of the parks planted with maples is equal to the number of the parks planted with oaks.
(B) The number of the parks planted with maples is greater than the number of the parks planted with sycamores.
(C) The number of the parks planted with oaks is equal to the number of the parks planted with sycamores.
(D) Graystone Park is planted with both maples and oaks.
(E) Landing Park is planted with both maples and oaks.
###"
"# Declarations
workers = EnumSort([Faith, Gus, Hannah, Juan, Kenneth, Lisa])
cars = EnumSort([car_1, car_2])
drives = Function([workers, cars] -> [bool])
travels = Function([workers, cars] -> [bool])

# Constraints
ForAll([w:workers], And(travels(w, car_1), travels(w, car_2))) ::: each car must carry at least two of the workers
ForAll([w:workers], And(drives(w, car_1), drives(w, car_2))) ::: one of whom will be assigned to drive
And(drives(Faith, car_1), drives(Gus, car_1)) ::: Either Faith or Gus must drive the car in which Hannah travels
And(drives(Faith, car_2), drives(Kenneth, car_2)) ::: Either Faith or Kenneth must drive the car in which Juan travels
travels(Gus, car_1) ::: Gus must travel in the same car as Lisa

# Options
Question ::: If Lisa drives one of the cars, then which one of the following could be true?
is_valid(And(drives(Lisa, car_1), travels(Faith, car_1))) ::: (A)
is_valid(And(drives(Lisa, car_1), travels(Faith, car_2))) ::: (B)
is_valid(And(drives(Lisa, car_2), travels(Gus, car_1))) ::: (C)
is_valid(And(drives(Lisa, car_2), travels(Gus, car_2))) ::: (D)
is_valid(And(drives(Lisa, car_2), travels(Hannah, car_1))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly six workers—Faith, Gus, Hannah, Juan, Kenneth, and Lisa—will travel to a business convention in two cars—car 1 and car 2. Each car must carry at least two of the workers, one of whom will be assigned to drive. For the entire trip, the workers will comply with an assignment that also meets the following constraints: Either Faith or Gus must drive the car in which Hannah travels. Either Faith or Kenneth must drive the car in which Juan travels. Gus must travel in the same car as Lisa.
Question:
If Lisa drives one of the cars, then which one of the following could be true?
Choices:
(A) Faith travels in the same car as Kenneth.
(B) Faith travels in the same car as Lisa.
(C) Gus travels in the same car as Hannah.
(D) Gus travels in the same car as Juan.
(E) Hannah travels in the same car as Lisa.
###"
"# Declarations
artifacts = EnumSort([figurine, headdress, jar, necklace, plaque, tureen])
age = Function([artifacts] -> [int])
ForAll([a:artifacts], And(1 <= age(a), age(a) <= 6))

# Constraints
ForAll([a:artifacts], And(age(a)!= age(figurine), age(a)!= age(jar), age(a)!= age(headdress))) ::: The figurine is older than both the jar and the headdress
ForAll([a:artifacts], And(age(a)!= age(jar), age(a)!= age(tureen))) ::: The necklace and the jar are both older than the tureen
Or(And(age(plaque) < age(headdress), age(plaque) < age(necklace)), And(age(headdress) < age(plaque), age(necklace) < age(plaque))) ::: Either the plaque is older than both the headdress and the necklace, or both the headdress and the necklace are older than the plaque

# Options
Question ::: Which one of the following artifacts CANNOT be fourth?
is_exception(is_sat(age(figurine) == 4)) ::: (A)
is_exception(is_sat(age(headdress) == 4)) ::: (B)
is_exception(is_sat(age(jar) == 4)) ::: (C)
is_exception(is_sat(age(necklace) == 4)) ::: (D)
is_exception(is_sat(age(plaque) == 4)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
An archaeologist has six ancient artifacts—a figurine, a headdress, a jar, a necklace, a plaque, and a tureen—no two of which are the same age. She will order them from first (oldest) to sixth (most recent). The following has already been determined: The figurine is older than both the jar and the headdress. The necklace and the jar are both older than the tureen. Either the plaque is older than both the headdress and the necklace, or both the headdress and the necklace are older than the plaque.
Question:
Which one of the following artifacts CANNOT be fourth?
Choices:
(A) figurine
(B) headdress
(C) jar
(D) necklace
(E) plaque
###"
"# Declarations
windows = EnumSort([window1, window2, window3])
colors = EnumSort([green, orange, purple, rose, yellow])
used = Function([windows, colors] -> [bool])

# Constraints
ForAll([w:windows], Count([c:colors], used(w, c)) >= 2) ::: each window contains at least two different colors of glass
ForAll([c:colors], Count([w:windows], used(w, c)) >= 1) ::: each color of glass will be used at least once
And(used(window1, green), used(window1, purple)) ::: Exactly one of the windows contains both green glass and purple glass
And(Count([w:windows], used(w, rose)) == 2) ::: Exactly two of the windows contain rose glass
ForAll([w:windows], Implies(used(w, yellow), Not(And(used(w, green), used(w, orange))))) ::: If a window contains yellow glass, then that window contains neither green glass nor orange glass
ForAll([w:windows], Implies(Not(used(w, purple)), used(w, orange))) ::: If a window does not contain purple glass, then that window contains orange glass

# Options
Question ::: If orange glass is used in more of the windows than green glass, then the complete color combination of the glass in one of the windows could be
is_sat(And(used(window1, orange), used(window1, purple))) ::: (A)
is_sat(And(used(window1, green), used(window1, purple), used(window1, rose))) ::: (B)
is_sat(And(used(window1, green), used(window1, purple))) ::: (C)
is_sat(And(used(window1, green), used(window1, orange))) ::: (D)
is_sat(And(used(window1, green), used(window1, rose))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
An artisan has been hired to create three stained glass windows. The artisan will use exactly five colors of glass: green, orange, purple, rose, and yellow. Each color of glass will be used at least once, and each window will contain at least two different colors of glass. The windows must also conform to the following conditions: Exactly one of the windows contains both green glass and purple glass. Exactly two of the windows contain rose glass. If a window contains yellow glass, then that window contains neither green glass nor orange glass. If a window does not contain purple glass, then that window contains orange glass.
Question:
If orange glass is used in more of the windows than green glass, then the complete color combination of the glass in one of the windows could be
Choices:
(A) orange and purple
(B) green, purple, and rose
(C) green and purple
(D) green and orange
(E) green, orange, and rose
###"
"# Declarations
films = EnumSort([Fiesta, Glaciers, Hurricanes, Jets, Kangaroos, Lovebird])
released = Function([films] -> [int])
ForAll([f:films], And(1 <= released(f), released(f) <= 6))

# Constraints
And(released(Fiesta) < released(Jets), released(Fiesta) < released(Lovebird)) ::: Fiesta must be released earlier than both Jets and Lovebird
And(released(Kangaroos) < released(Jets), released(Jets) < released(Hurricanes)) ::: Kangaroos must be released earlier than Jets, and Jets must be released earlier than Hurricanes
released(Lovebird) < released(Glaciers) ::: Lovebird must be released earlier than Glaciers

# Options
Question ::: Which one of the following must be true?
is_sat(released(Fiesta) < released(Hurricanes)) ::: (A)
is_sat(released(Jets) < released(Glaciers)) ::: (B)
is_sat(released(Kangaroos) < released(Glaciers)) ::: (C)
is_sat(released(Lovebird) < released(Hurricanes)) ::: (D)
is_sat(released(Lovebird) < released(Jets)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A movie studio is scheduling the release of six films—Fiesta, Glaciers, Hurricanes, Jets, Kangaroos, and Lovebird. No two of these films can be released on the same date. The release schedule is governed by the following conditions: Fiesta must be released earlier than both Jets and Lovebird. Kangaroos must be released earlier than Jets, and Jets must be released earlier than Hurricanes. Lovebird must be released earlier than Glaciers.
Question:
Which one of the following must be true?
Choices:
(A) Fiesta is released earlier than Hurricanes.
(B) Jets is released earlier than Glaciers.
(C) Kangaroos is released earlier than Glaciers.
(D) Lovebird is released earlier than Hurricanes.
(E) Lovebird is released earlier than Jets.
###"
"# Declarations
recycling_centers = EnumSort([Center_1, Center_2, Center_3])
materials = EnumSort([glass, newsprint, plastic, tin, wood])
recycles = Function([recycling_centers, materials] -> [bool])

# Constraints
ForAll([c:recycling_centers], Count([m:materials], recycles(c, m)) >= 2) ::: Each recycling center recycles at least two but no more than three of these kinds of material
ForAll([m:materials], Count([c:recycling_centers], recycles(c, m)) <= 3) ::: Each recycling center recycles at least two but no more than three of these kinds of material
And(recycles(Center_2, wood), recycles(Center_2, newsprint)) ::: Any recycling center that recycles wood also recycles newsprint
ForAll([m:materials], Implies(recycles(Center_2, m), recycles(Center_1, m))) ::: Every kind of material that Center 2 recycles is also recycled at Center 1
ForAll([m:materials], Implies(recycles(Center_2, m), Not(recycles(Center_3, m)))) ::: Only one of the recycling centers recycles plastic, and that recycling center does not recycle glass

# Options
Question ::: If Center 2 recycles three kinds of material, then which one of the following kinds of material must Center 3 recycle?
is_sat(And(recycles(Center_2, glass), recycles(Center_2, newsprint), recycles(Center_2, wood), recycles(Center_3, glass))) ::: (A)
is_sat(And(recycles(Center_2, glass), recycles(Center_2, newsprint), recycles(Center_2, wood), recycles(Center_3, newsprint))) ::: (B)
is_sat(And(recycles(Center_2, glass), recycles(Center_2, newsprint), recycles(Center_2, wood), recycles(Center_3, plastic))) ::: (C)
is_sat(And(recycles(Center_2, glass), recycles(Center_2, newsprint), recycles(Center_2, wood), recycles(Center_3, tin))) ::: (D)
is_sat(And(recycles(Center_2, glass), recycles(Center_2, newsprint), recycles(Center_2, wood), recycles(Center_3, wood))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
There are exactly three recycling centers in Rivertown: Center 1, Center 2, and Center 3. Exactly five kinds of material are recycled at these recycling centers: glass, newsprint, plastic, tin, and wood. Each recycling center recycles at least two but no more than three of these kinds of material. The following conditions must hold: Any recycling center that recycles wood also recycles newsprint. Every kind of material that Center 2 recycles is also recycled at Center 1. Only one of the recycling centers recycles plastic, and that recycling center does not recycle glass.
Question:
If Center 2 recycles three kinds of material, then which one of the following kinds of material must Center 3 recycle?
Choices:
(A) glass
(B) newsprint
(C) plastic
(D) tin
(E) wood
###"
"# Declarations
classes = EnumSort([gymnastics, jazz_dance, kung_fu, meditation, tennis, yoga])
starts = Function([classes] -> [int])
ForAll([c:classes], 5 <= starts(c) <= 8)

# Constraints
And(starts(yoga) > starts(jazz_dance), starts(yoga) <= starts(kung_fu)) ::: Yoga begins later than jazz dance but no later than kung fu
And(starts(meditation) == starts(c), ForAll([c:classes], c!= meditation)) ::: Meditation begins at the same time as exactly one other introductory class
ForAll([c:classes], Not(starts(c) == starts(gymnastics))) ::: No other introductory class begins at the same time as gymnastics
Count([c:classes], starts(c) > starts(gymnastics)) <= 1 ::: At most one of the other introductory classes begins later than gymnastics

# Options
Question ::: Which one of the following introductory classes CANNOT be scheduled to start at 6 P.M.?
is_exception(is_sat(starts(gymnastics) == 6)) ::: (A)
is_exception(is_sat(starts(jazz_dance) == 6)) ::: (B)
is_exception(is_sat(starts(kung_fu) == 6)) ::: (C)
is_exception(is_sat(starts(meditation) == 6)) ::: (D)
is_exception(is_sat(starts(tennis) == 6)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
On Tuesday evenings, the Community Center offers one session of each of the following six introductory classes: gymnastics, jazz dance, kung fu, meditation, tennis, and yoga. No other introductory classes are offered on Tuesdays. Each class is scheduled for exactly one hour, beginning at 5 P.M., 6 P.M., 7 P.M., or 8 P.M. Tuesdays schedule conforms to the following conditions: Yoga begins later than jazz dance but no later than kung fu. Meditation begins at the same time as exactly one other introductory class. No other introductory class begins at the same time as gymnastics. At most one of the other introductory classes begins later than gymnastics.
Question:
Which one of the following introductory classes CANNOT be scheduled to start at 6 P.M.?
Choices:
(A) gymnastics
(B) jazz dance
(C) kung fu
(D) meditation
(E) tennis
###"
"# Declarations
workers = EnumSort([Brandt, Calva, Duvall, Eberle, Fu, Garcia, Haga, Irving, Jessup])
hired = Function([workers] -> [int])
ForAll([w:workers], And(1 <= hired(w), hired(w) <= 9))

# Constraints
Distinct([w:workers], hired(w)) ::: no two workers were hired on the same day
And(hired(Fu) == hired(Irving), ForAll([w:workers], Implies(w!= Fu, w!= Irving, hired(w)!= hired(Fu)))) ::: Fu and Irving were hired on the same day as each other, and no one else was hired that day
And(hired(Calva) == hired(Garcia), ForAll([w:workers], Implies(w!= Calva, w!= Garcia, hired(w)!= hired(Calva)))) ::: Calva and Garcia were hired on the same day as each other, and no one else was hired that day
ForAll([w:workers], Implies(w!= Eberle, hired(w) < hired(Eberle))) ::: Eberle was hired before Brandt
ForAll([w:workers], Implies(w!= Haga, hired(w) < hired(Haga))) ::: Haga was hired before Duvall
And(hired(Duvall) > hired(Irving), hired(Duvall) < hired(Eberle)) ::: Duvall was hired after Irving but before Eberle
hired(Garcia) > hired(Jessup) ::: Garcia was hired after both Jessup and Brandt
hired(Brandt) < hired(Jessup) ::: Brandt was hired before Jessup

# Options
Question ::: Who was hired on the fourth day of hiring?
is_valid(hired(Eberle) == 4) ::: (A)
is_valid(hired(Brandt) == 4) ::: (B)
is_valid(hired(Irving) == 4)------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
The Mammoth Corporation has just completed hiring nine new workers: Brandt, Calva, Duvall, Eberle, Fu, Garcia, Haga, Irving, and Jessup. Fu and Irving were hired on the same day as each other, and no one else was hired that day. Calva and Garcia were hired on the same day as each other, and no one else was hired that day. On each of the other days of hiring, exactly one worker was hired. Eberle was hired before Brandt. Haga was hired before Duvall. Duvall was hired after Irving but before Eberle. Garcia was hired after both Jessup and Brandt. Brandt was hired before Jessup.
Question:
Who was hired on the fourth day of hiring?
Choices:
(A) Eberle
(B) Brandt
(C) Irving
(D) Garcia
(E) Jessup
###"
"# Declarations
illnesses = EnumSort([J, K, L, M, N])
symptoms = EnumSort([fever, headache, sneezing])
has_symptom = Function([illnesses, symptoms] -> [bool])

# Constraints
And(has_symptom(J, headache), has_symptom(J, sneezing)) ::: Illness J is characterized by headache and sneezing
ForAll([s:symptoms], Implies(has_symptom(J, s), Not(has_symptom(K, s)))) ::: Illnesses J and K have no symptoms in common
Exists([s:symptoms], And(has_symptom(J, s), has_symptom(L, s))) ::: Illnesses J and L have at least one symptom in common
Count([s:symptoms], has_symptom(L, s)) > Count([s:symptoms], has_symptom(K, s)) ::: Illness L has a greater number of symptoms than illness K
ForAll([s:symptoms], Implies(has_symptom(L, s), Not(has_symptom(N, s)))) ::: Illnesses L and N have no symptoms in common
Count([s:symptoms], has_symptom(M, s)) > Count([s:symptoms], has_symptom(J, s)) ::: Illness M has more symptoms than illness J

# Options
Question ::: If illness L is characterized by a combination of symptoms different from any of the other illnesses, then which one of the following statements must be true?
is_sat(ForAll([s:symptoms], Implies(has_symptom(L, s), Not(has_symptom(K, s))))) ::: (A)
is_sat(ForAll([s:symptoms], Implies(has_symptom(L, s), Not(has_symptom(N, s))))) ::: (B)
is_sat(ForAll([s:symptoms], Implies(has_symptom(L, s), Not(has_symptom(M, s))))) ::: (C)
is_sat(ForAll([s:symptoms], Implies(has_symptom(K, s), has_symptom(N, s)))) ::: (D)
is_sat(ForAll([s:symptoms], Implies(has_symptom(M, s), has_symptom(N, s)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Each of five illnesses—J, K, L, M, and N—is characterized by at least one of the following three symptoms: fever, headache, and sneezing. None of the illnesses has any symptom that is not one of these three. Illness J is characterized by headache and sneezing. Illnesses J and K have no symptoms in common. Illnesses J and L have at least one symptom in common. Illness L has a greater number of symptoms than illness K. Illnesses L and N have no symptoms in common. Illness M has more symptoms than illness J.
Question:
If illness L is characterized by a combination of symptoms different from any of the other illnesses, then which one of the following statements must be true?
Choices:
(A) Fever is a symptom of illness L.
(B) Sneezing is a symptom of illness L.
(C) Headache is a symptom of illness L.
(D) Illnesses K and N are characterized by exactly the same symptoms.
(E) Illnesses M and N are characterized by exactly the same symptoms.
###"
"# Declarations
chalets = EnumSort([J, K, L, M, N, O])
path = Function([chalets, chalets] -> [bool])

# Constraints
ForAll([c:chalets], Count([c2:chalets], path(c, c2)) == 1) ::: Each chalet is directly connected by a segment of the path to another chalet
ForAll([c:chalets], Count([c2:chalets], path(c, c2)) <= 2) ::: No chalet is directly connected by segments of the path to more than two other chalets
path(J, N) ::: One segment of the path directly connects chalets J and N
path(K, L) ::: One segment of the path directly connects chalets K and L

# Options
Question ::: If one segment of the path directly connects chalets K and N, then the two chalets in which one of the following pairs must be directly connected to each other by a segment?
is_sat(path(J, K)) ::: (A)
is_sat(path(K, O)) ::: (B)
is_sat(path(L, O)) ::: (C)
is_sat(path(M, N)) ::: (D)
is_sat(path(N, O)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
J, K, L, M, N, and O are square ski chalets of the same size, which are positioned in two straight rows as shown below: J K L row 1: ■ ■ ■ row 2: ■ ■ ■ M N O J is directly opposite M; K is directly opposite N; and L is directly opposite O. After a snowstorm, residents shovel a single continuous path that connects all of the chalets and meets the following conditions: The path is composed of five straight segments, each of which directly connects exactly two of the chalets. Each chalet is directly connected by a segment of the path to another chalet. No chalet is directly connected by segments of the path to more than two other chalets. No segment of the path crosses any other segment. One segment of the path directly connects chalets J and N, and another segment directly connects chalets K and L.
Question:
If one segment of the path directly connects chalets K and N, then the two chalets in which one of the following pairs must be directly connected to each other by a segment?
Choices:
(A) J and K
(B) K and O
(C) L and O
(D) M and N
(E) N and O
###"
"# Declarations
islands = EnumSort([J, K, L, M, O])
bridges = Function([islands, islands] -> [bool])

# Constraints
ForAll([i:islands], Count([j:islands], bridges(i, j)) <= 3) ::: no island has more than three bridges that directly connect it with other islands
ForAll([i:islands], Count([j:islands], bridges(i, j)) >= 1) ::: each island is directly connected by bridge with one or both of M and O
And(Count([j:islands], bridges(J, j)) == 2, Count([j:islands], bridges(K, j)) == 1) ::: J is directly connected by bridge with exactly two islands, and K is directly connected by bridge with exactly one island
bridges(J, O) ::: A bridge directly connects J with O
bridges(M, O) ::: A bridge directly connects M with O

# Options
Question ::: If no island that is directly connected by bridge with M is also directly connected by bridge with O, then there must be a bridge directly connecting
is_sat(Exists([i:islands], bridges(i, L))) ::: (A)
is_sat(Exists([i:islands], bridges(i, M))) ::: (B)
is_sat(Exists([i:islands], bridges(i, O))) ::: (C)
is_sat(Exists([i:islands], bridges(L, M))) ::: (D)
is_sat(Exists([i:islands], bridges(L, O))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A lake contains exactly five islands—J, K, L, M, O—which are unconnected by bridges. Contractors will build a network of bridges that satisfies the following specifications: Each bridge directly connects exactly two islands with each other, and no two bridges intersect. No more than one bridge directly connects any two islands. No island has more than three bridges that directly connect it with other islands. J, K, and L are each directly connected by bridge with one or both of M and O. J is directly connected by bridge with exactly two islands. K is directly connected by bridge with exactly one island. A bridge directly connects J with O, and a bridge directly connects M with O.
Question:
If no island that is directly connected by bridge with M is also directly connected by bridge with O, then there must be a bridge directly connecting
Choices:
(A) J with L
(B) J with M
(C) K with O
(D) L with M
(E) L with O
###"
"# Declarations
subjects = EnumSort([mathematics, nutrition, oceanography])
semesters = EnumSort([fall, spring])
folders = EnumSort([1, 2, 3, 4, 5, 6])
orders = Function([subjects, semesters] -> [folders])

# Constraints
ForAll([s:subjects, f:folders], Count([se:semesters], orders(s, se) == f) <= 1) ::: Each folder contains only the orders for one of the six course offerings
orders(mathematics, fall) == 1 or orders(mathematics, fall) == 4 ::: The fall mathematics orders are in folder 1 or else folder 4
orders(oceanography, spring) == 1 or orders(oceanography, spring) == 4 ::: The spring oceanography orders are in folder 1 or else folder 4
Not(orders(nutrition, spring) == 5) ::: The spring nutrition orders are not in folder 5

# Options
Question ::: Which one of the following could be true?
is_sat(orders(mathematics, fall) == 1 and orders(oceanography, spring) == 2) ::: (A)
is_sat(orders(nutrition, spring) == 5) ::: (B)
is_sat(orders(nutrition, spring)!= 6) ::: (C)
is_sat(orders(mathematics, fall) == 1 and orders(mathematics, fall) == 4) ::: (D)
is_sat(orders(mathematics, fall) == 1 and orders(oceanography, spring) == 4 and orders(nutrition, fall) == 6) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A college offers one course in each of three subjects—mathematics, nutrition, and oceanography—in the fall and again in the spring. Students' book orders for these course offerings are kept in six folders, numbered 1 through 6, from which labels identifying the folders' contents are missing. The following is known: Each folder contains only the orders for one of the six course offerings. Folder 1 contains orders for the same subject as folder 2 does. The orders in folder 3 are for a different subject than are the orders in folder 4. The fall mathematics orders are in folder 1 or else folder 4. The spring oceanography orders are in folder 1 or else folder 4. The spring nutrition orders are not in folder 5.
Question:
Which one of the following could be true?
Choices:
(A) The fall mathematics and spring oceanography orders are in folders with consecutive numbers.
(B) Folder 5 contains the orders for a spring course in a subject other than mathematics.
(C) Folder 6 contains the orders for a subject other than nutrition.
(D) The mathematics orders are in folders 1 and 4.
(E) The orders for the fall courses are in folders 1, 3, and 6.
###"
"# Declarations
lines = EnumSort([Ll, L2, L3, L4, L5])
stations = EnumSort([Rincon, Tonka, French, Semplain, Urstine, Quetzal, Park, Greene])
connects = Function([lines, stations] -> [bool])

# Constraints
ForAll([l:lines], ForAll([s:stations], connects(l, s))) ::: Along each of the lines, trains run in both directions, stopping at every station
And(connects(Ll, Rincon), connects(Ll, Tonka), connects(Ll, French), connects(Ll, Semplain), connects(Ll, Urstine), connects(Ll, Quetzal), connects(Ll, Park)) ::: Ll runs in a loop connecting exactly seven stations
And(connects(L2, Tonka), connects(L2, Semplain)) ::: L2 connects Tonka with Semplain, and with no other station
And(connects(L3, Rincon), connects(L3, Urstine)) ::: L3 connects Rincon with Urstine, and with no other station
And(connects(L4, Quetzal), connects(L4, Greene), connects(L4, Rincon)) ::: L4 runs from Quetzal through exactly one other station, Greene, to Rincon
And(connects(L5, Quetzal), connects(L5, Tonka)) ::: L5 connects Quetzal with Tonka, and with no other station

# Options
Question ::: If a sixth subway line is to be constructed so that all of the stations would have two or more lines reaching them, the stations connected by the new subway line must include at least
is_valid(ForAll([s:stations], Count([l:lines], connects(l, s)) >= 2)) ::: (A)
is_valid(ForAll([s:stations], Count([l:lines], connects(l, s)) >= 2)) ::: (B)
is_valid(ForAll([s:stations], Count([l:lines], connects(l, s)) >= 2)) ::: (C)
is_valid(ForAll([s:stations], Count([l:lines], connects(l, s)) >= 2)) ::: (D)
is_valid(ForAll([s:stations], Count([l:lines], connects(l, s)) >= 2)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Greenburg has exactly five subway lines: Ll, L2, L3, L4, and L5. Along each of the lines, trains run in both directions, stopping at every station. Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel, and the reverse in the other direction. L2 connects Tonka with Semplain, and with no other station. L3 connects Rincon with Urstine, and with no other station. L4 runs from Quetzal through exactly one other station, Greene, to Rincon. L5 connects Quetzal with Tonka, and with no other station.
Question:
If a sixth subway line is to be constructed so that all of the stations would have two or more lines reaching them, the stations connected by the new subway line must include at least
Choices:
(A) French, Greene, and Park
(B) French, Greene, and Quetzal
(C) French, Greene, and Rincon
(D) Park, Tonka, and Urstine
(E) Park, Semplain, and Tonka
###"
"# Declarations
organisms = EnumSort([W, X, Y, Z])
antibiotics = EnumSort([ferromycin, ganocyclene, heptocillin])
responds = Function([organisms, antibiotics] -> [bool])

# Constraints
ForAll([o:organisms], Exists([a:antibiotics], responds(o, a))) ::: Each of the organisms responds to at least one of the antibiotics
ForAll([o:organisms], Count([a:antibiotics], responds(o, a)) <= 2) ::: No organism responds to all three antibiotics
Count([o:organisms], responds(o, ferromycin)) >= 2 ::: At least two but not all four of the organisms respond to ferromycin
ForAll([a:antibiotics], Implies(responds(W, a), responds(X, a))) ::: If W responds to any antibiotic, then X responds to that antibiotic
ForAll([o:organisms], Implies(responds(o, ferromycin), responds(o, ganocyclene))) ::: If an organism responds to ferromycin, then it responds to ganocyclene
responds(Y, ferromycin) ::: Y responds to ferromycin

# Options
Question ::: Each of the following can be true EXCEPT:
is_exception(is_sat(responds(W, heptocillin))) ::: (A)
is_exception(is_sat(responds(X, ganocyclene))) ::: (B)
is_exception(is_sat(responds(X, heptocillin))) ::: (C)
is_exception(is_sat(responds(Y, heptocillin))) ::: (D)
is_exception(is_sat(responds(Z, ganocyclene))) ::: (E------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.
Question:
Each of the following can be true EXCEPT:
Choices:
(A) W responds to heptocillin.
(B) X responds to ganocyclene.
(C) X responds to heptocillin.
(D) Y responds to heptocillin.
(E) Z responds to ganocyclene.
###"
"# Declarations
people = EnumSort([J, K, L, M, N, P, Q])
selected = Function([people] -> [bool])

# Constraints
Or(selected(J), selected(K)) ::: Either J or K must be selected
Not(And(selected(J), selected(K))) ::: J and K cannot both be selected
Or(selected(N), selected(P)) ::: Either N or P must be selected
Not(And(selected(N), selected(P))) ::: N and P cannot both be selected
Implies(selected(N), selected(L)) ::: N cannot be selected unless L is selected
Implies(selected(Q), selected(K)) ::: Q cannot be selected unless K is selected

# Options
Question ::: If M is not selected to attend the retirement dinner, the four people selected to attend must include which one of the following pairs of people?
is_sat(And(Not(selected(M)), selected(J), selected(Q))) ::: (A)
is_sat(And(Not(selected(M)), selected(K), selected(L))) ::: (B)
is_sat(And(Not(selected(M)), selected(K), selected(P))) ::: (C)
is_sat(And(Not(selected(M)), selected(L), selected(P))) ::: (D)
is_sat(And(Not(selected(M)), selected(N), selected(Q))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.
Question:
If M is not selected to attend the retirement dinner, the four people selected to attend must include which one of the following pairs of people?
Choices:
(A) J and Q
(B) K and L
(C) K and P
(D) L and P
(E) N and Q
###"
"# Declarations
lectures = EnumSort([fresco, history, lithography, naturalism, oils, pastels, sculpture, watercolors])
days = EnumSort([1, 2, 3])
scheduled = Function([lectures, days] -> [bool])

# Constraints
ForAll([l:lectures, d:days], scheduled(l, d) == False) ::: no lectures are scheduled
ForAll([d:days], Count([l:lectures], scheduled(l, d)) == 2) ::: there will be exactly two lectures each day
ForAll([l:lectures], Implies(scheduled(l, 2), l == oils)) ::: Day 2 is the only day for which oils can be scheduled
ForAll([l:lectures], Implies(scheduled(l, 3), l!= sculpture, l!= watercolors)) ::: Neither sculpture nor watercolors can be scheduled for the afternoon
ForAll([l:lectures], Implies(scheduled(l, 1), l!= oils, l!= pastels)) ::: Neither oils nor pastels can be scheduled for the same day as lithography
ForAll([d:days], Implies(scheduled(pastels, d), And(scheduled(fresco, d + 1), scheduled(history, d + 1)))) ::: If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order

# Options
Question ::: If lithography and fresco are scheduled for the afternoons of day 2 and day 3, respectively, which one of the following is a lecture that could be scheduled for the afternoon of day 1?
is_sat------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
An art teacher will schedule exactly six of eight lectures—fresco, history, lithography, naturalism, oils, pastels, sculpture, and watercolors—for three days—1, 2, and 3. There will be exactly two lectures each day—morning and afternoon. Scheduling is governed by the following conditions: Day 2 is the only day for which oils can be scheduled. Neither sculpture nor watercolors can be scheduled for the afternoon. Neither oils nor pastels can be scheduled for the same day as lithography. If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order.
Question:
If lithography and fresco are scheduled for the afternoons of day 2 and day 3, respectively, which one of the following is a lecture that could be scheduled for the afternoon of day 1?
Choices:
(A) history
(B) oils
(C) pastels
(D) sculpture
(E) watercolors
###"
"# Declarations
clans = EnumSort([N, O, P, S, T])
participates = Function([clans, int] -> [bool])
ForAll([c:clans, y:int], And(0 <= y, y <= 5))

# Constraints
ForAll([c:clans], ForAll([y:int], Implies(And(participates(c, y), participates(c, y + 1)), participates(c, y + 2)))) ::: Each clan must participate at least once in any two consecutive years
ForAll([c:clans], ForAll([y:int], Implies(participates(c, y), Not(participates(c, y + 3))))) ::: No clan participates for three consecutive years
ForAll([c:clans], ForAll([y:int], Implies(participates(c, y), participates(c, y + 1)))) ::: Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times
ForAll([c:clans], ForAll([y:int], Implies(participates(c, y), Not(participates(c, y + 4))))) ::: No clan participates more than three times within any cycle

# Options
Question ::: Which one of the following must be true about the three clans that participate in the ceremonies in the first year?
is_valid(ForAll([c:clans], Implies(participates(c, 1), Not(participates(c, 3))))) ::: (A)
is_valid(ForAll([c:clans], Implies(participates(c, 1), participates(c, 2)))) ::: (B)
is_valid(ForAll([c:clans], Implies(participates(c, 1), participates(c, 4)))) ::: (C)
is_valid(ForAll([c:clans], Implies(participates(c, 1), participates(c, 5)))) ::: (D)
is_valid(ForAll([c:clans], Implies(participates(c, 1), Not(participates(c, 3))))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.
Question:
Which one of the following must be true about the three clans that participate in the ceremonies in the first year?
Choices:
(A) At most two of them participate together in the third year.
(B) At least two of them participate together in the second year.
(C) All three of them participate together in the fourth year.
(D) All three of them participate together in the fifth year.
(E) None of them participates in the third year.
###"
"# Declarations
students = EnumSort([H, J, K, R, S, T])
speeches = Function([students] -> [int])
ForAll([s:students], And(1 <= speeches(s), speeches(s) <= 6))

# Constraints
Distinct([s:students], speeches(s)) ::: The speeches will be delivered one at a time, consecutively
And(speeches(H)!= speeches(J) - 1, speeches(H)!= speeches(K) - 1, speeches(J)!= speeches(K) - 1) ::: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches
And(speeches(R)!= speeches(S) - 1, speeches(R)!= speeches(T) - 1, speeches(S)!= speeches(T) - 1) ::: The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches
speeches(H) < speeches(S) ::: H's speech must be earlier than S's speech
speeches(J)!= 1 ::: J's speech can be neither first nor sixth
speeches(T)!= speeches(J) - 1 ::: T's speech can be neither immediately before nor immediately after J's speech

# Options
Question ::: If K delivers the first speech and H delivers the fifth speech, which one of the following must be true?
is_sat(speeches(R) == 3) ::: (A)
is_sat(speeches(T) == 4) ::: (B)
is_sat(speeches(J) == speeches(H) - 1) ::: (C)
is_sat(speeches(K) == speeches(T) - 1) ::: (D)
is_sat(speeches(R) == speeches(J) - 1) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.
Question:
If K delivers the first speech and H delivers the fifth speech, which one of the following must be true?
Choices:
(A) R delivers the third speech.
(B) T delivers the fourth speech.
(C) J's speech is immediately before H's speech.
(D) K's speech is immediately before T's speech.
(E) R's speech is immediately before J's speech.
###"
"# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: If Wendy eats poached eggs for breakfast, then which one of the following statements cannot be true?
is_exception(is_sat(And(eats(Wendy, breakfast) == poached_eggs, eats(Vladimir, lunch) == fish))) ::: (A)
is_exception(is_sat(And(eats(Wendy, breakfast) == poached_eggs, eats(Vladimir, lunch) == hot_cakes))) ::: (B)
is_exception(is_sat(And(eats(Wendy, breakfast) == poached_eggs, eats(Vladimir, dinner) == macaroni))) ::: (------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
If Wendy eats poached eggs for breakfast, then which one of the following statements cannot be true?
Choices:
(A) Vladimir eats fish for lunch.
(B) Vladimir eats hot cakes for lunch.
(C) Vladimir eats macaroni for dinner.
(D) Wendy eats hot cakes for dinner.
(E) Wendy eats macaroni for dinner.
###"
"# Declarations
boats = EnumSort([boat1, boat2])
people = EnumSort([F, G, H, V, W, X, Y, Z])
adults = EnumSort([F, G, H])
children = EnumSort([V, W, X, Y, Z])
assigned = Function([boats, people] -> [bool])

# Constraints
ForAll([b:boats], Count([p:people], assigned(b, p)) == 4) ::: Each boat is assigned exactly four people
ForAll([b:boats], Count([a:adults], assigned(b, a)) >= 1) ::: Each boat is assigned at least one adult
ForAll([p:people], Implies(assigned(boat2, p), assigned(boat2, F) == assigned(boat2, G))) ::: If F is assigned to boat 2, G is assigned to boat 2
ForAll([p:people], Implies(assigned(boat1, p), assigned(boat2, W))) ::: If V is assigned to boat 1, W is assigned to boat 2
assigned(boat1, X)!= assigned(boat1, Z) ::: X and Z are assigned to different boats

# Options
Question ::: If G is assigned to boat 1, which one of the following must be true?
is_sat(assigned(boat2, H)) ::: (A)
is_sat(assigned(boat2, V)) ::: (B)
is_sat(Count([a:adults], assigned(boat1, a)) == 1) ::: (C)
is_sat(Count([a:adults], assigned(boat2, a)) == 2) ::: (D)
is_sat(Count([c:children], assigned(boat2, c)) == 2) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.
Question:
If G is assigned to boat 1, which one of the following must be true?
Choices:
(A) H is assigned to boat 2.
(B) V is assigned to boat 2.
(C) Exactly one adult is assigned to boat 1.
(D) Exactly two adults are assigned to boat 2.
(E) Exactly two children are assigned to boat 2.
###"
"# Declarations
boats = EnumSort([boat1, boat2])
people = EnumSort([F, G, H, V, W, X, Y, Z])
assigned = Function([boats, people] -> [bool])

# Constraints
ForAll([b:boats], Count([p:people], assigned(b, p)) == 4) ::: Each boat is assigned exactly four people
ForAll([p:people], Count([b:boats], assigned(b, p)) == 1) ::: Each person is assigned to exactly one boat
ForAll([p:people], Implies(assigned(boat2, p), p == F)) ::: If F is assigned to boat 2, G is assigned to boat 2
ForAll([p:people], Implies(assigned(boat1, p), p == V)) ::: If V is assigned to boat 1, W is assigned to boat 2
assigned(boat1, X)!= assigned(boat1, Z) ::: X and Z are assigned to different boats

# Options
Question ::: If H is assigned to a different boat than Y, which one of the following must be assigned to boat 1?
is_valid(Implies(assigned(boat1, H), assigned(boat1, F))) ::: (A)
is_valid(Implies(assigned(boat1, H), assigned(boat1, G))) ::: (B)
is_valid(Implies(assigned(boat1, H), assigned(boat1, H))) ::: (C)
is_valid(Implies(assigned(boat1, H), assigned(boat1, V))) ::: (D)
is_valid(Implies(assigned(boat1, H), assigned(boat1, Y))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.
Question:
If H is assigned to a different boat than Y, which one of the following must be assigned to boat 1?
Choices:
(A) F
(B) G
(C) H
(D) V
(E) Y
###"
"# Declarations
singers = EnumSort([Jamie, Ken, Lalitha, Maya, Norton, Olive, Patrick])
performs = Function([singers] -> [int])
ForAll([s:singers], And(1 <= performs(s), performs(s) <= 7))

# Constraints
And(performs(Jamie) == performs(Ken) + 1, performs(Patrick) > performs(Maya)) ::: Jamie performs immediately after Ken. Patrick performs at some time after Maya.
Implies(performs(Patrick)!= 2, performs(Patrick) == 5) ::: If Patrick does not perform second, he performs fifth.
Implies(performs(Lalitha) == 3, performs(Norton) == 5) ::: Lalitha performs third only if Norton performs fifth.

# Options
Question ::: Which one of the following is an acceptable schedule for the evening's performers, from first through seventh?
is_sat(And(performs(Ken) == 1, performs(Jamie) == 2, performs(Maya) == 3, performs(Lalitha) == 4, performs(Patrick) == 5, performs(Norton) == 6, performs(Olive) == 7)) ::: (A)
is_sat(And(performs(Lalitha) == 1, performs(Patrick) == 2, performs(Norton) == 3, performs(Olive) == 4, performs(Maya) == 5, performs(Ken) == 6, performs(Jamie) == 7)) ::: (B)
is_sat(And(performs(Norton) == 1, performs(Olive) == 2, performs(Ken) == 3, performs(Jamie) == 4, performs(Maya) == 5, performs(Patrick) == 6, performs(Lalitha) == 7)) ::: (C)
is_sat(And(performs(Olive) == 1, performs(Maya) == 2, performs(Ken) == 3, performs(Lalitha) == 4, performs(Patrick) == 5, performs(Norton) == 6, performs(Jamie) == 7)) ::: (D)
is_sat(And(performs(Olive) == 1, performs(Maya) == 2, performs(Lalitha) == 3, performs(Norton) == 4, performs(Patrick) == 5, performs(Ken) == 6, performs(Jamie) == 7)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.
Question:
Which one of the following is an acceptable schedule for the evening's performers, from first through seventh?
Choices:
(A) Ken, Jamie, Maya, Lalitha, Patrick, Norton, Olive
(B) Lalitha, Patrick, Norton, Olive, Maya, Ken, Jamie
(C) Norton, Olive, Ken, Jamie, Maya, Patrick, Lalitha
(D) Olive, Maya, Ken, Lalitha, Patrick, Norton, Jamie
(E) Olive, Maya, Lalitha, Norton, Patrick, Ken, Jamie
###"
"# Declarations
singers = EnumSort([Jamie, Ken, Lalitha, Maya, Norton, Olive, Patrick])
performances = Function([singers] -> [int])
ForAll([s:singers], And(1 <= performances(s), performances(s) <= 7))

# Constraints
And(performances(Jamie) == performances(Ken) + 1, performances(Patrick) > performances(Maya)) ::: Jamie performs immediately after Ken. Patrick performs at some time after Maya.
Implies(performances(Lalitha) == 3, performances(Norton) == 5) ::: Lalitha performs third only if Norton performs fifth.
Implies(Not(performances(Patrick) == 2), performances(Patrick) == 5) ::: If Patrick does not perform second, he performs fifth.

# Options
Question ::: If Jamie's performance is scheduled to be immediately before Lalitha's performance, Jamie's performance CANNOT be scheduled to be
is_sat(And(performances(Jamie) == performances(Lalitha) - 1, performances(Jamie) == 2)) ::: (A)
is_sat(And(performances(Jamie) == performances(Lalitha) - 1, performances(Jamie) == 3)) ::: (B)
is_sat(And(performances(Jamie) == performances(Lalitha) - 1, performances(Jamie) == 4)) ::: (C)
is_sat(And(performances(Jamie) == performances(Lalitha) - 1, performances(Jamie) == 5)) ::: (D)
is_sat(And(performances(Jamie) == performances(Lalitha) - 1, performances(Jamie) == 6)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.
Question:
If Jamie's performance is scheduled to be immediately before Lalitha's performance, Jamie's performance CANNOT be scheduled to be
Choices:
(A) second
(B) third
(C) fourth
(D) fifth
(E) sixth
###"
"# Declarations
packages = EnumSort([L, M, N, O, P, S, T])
delivered = Function([packages] -> [int])
ForAll([p:packages], And(1 <= delivered(p), delivered(p) <= 7))

# Constraints
Distinct([p:packages], delivered(p)) ::: no two packages are delivered at the same time
Or(delivered(P) == 1, delivered(P) == 7) ::: P is delivered either first or seventh
delivered(N) > delivered(L) ::: The messenger delivers N at some time after delivering L
delivered(T) > delivered(M) ::: The messenger delivers T at some time after delivering M
Exists([p:packages], And(delivered(p) == 2, Exists([q:packages], And(delivered(q) == 3, Or(p == L, p == O))))) ::: The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O
Exists([p:packages], And(delivered(p) == 6, Exists([q:packages], And(delivered(q) == 5, Or(p == M, p == P))))) ::: The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P

# Options
Question ::: Which one of the following could be true?
is_sat(delivered(N) == 1) ::: (A)
is_sat(delivered(T) == 1) ::: (B)
is_sat(delivered(T) == 2) ::: (C)
is_sat(delivered(M) == 4) ::: (D)
is_sat(delivered(S) == 7) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.
Question:
Which one of the following could be true?
Choices:
(A) N is delivered first.
(B) T is delivered first.
(C) T is delivered second.
(D) M is delivered fourth.
(E) S is delivered seventh.
###"
"# Declarations
cars = EnumSort([1, 2, 3, 4, 5, 6])
colors = EnumSort([green, orange, purple])
color = Function([cars] -> [colors])

# Constraints
ForAll([c:cars], color(c)!= green) ::: No car can be the same color as any car next to it in line
ForAll([c:cars], Implies(c == 5, color(c) == purple)) ::: Either car 5 or car 6 must be purple
color(1)!= orange ::: Car 1 cannot be orange
color(4)!= green ::: Car 4 cannot be green

# Options
Question ::: The cars in which one of the following pairs CANNOT be the same color as each other?
is_sat(ForAll([c:cars], Implies(c == 1, color(c)!= color(4)))) ::: (A)
is_sat(ForAll([c:cars], Implies(c == 1, color(c)!= color(5)))) ::: (B)
is_sat(ForAll([c:cars], Implies(c == 3, color(c)!= color(5)))) ::: (C)
is_sat(ForAll([c:cars], Implies(c == 3, color(c)!= color(6)))) ::: (D)
is_sat(ForAll([c:cars], Implies(c == 4, color(c)!= color(6)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Six cars are to be arranged in a straight line, and will be numbered 1 through 6, in order, from the front of the line to the back of the line. Each car is exactly one color: two are green, two are orange, and two are purple. The arrangement of cars is restricted as follows: No car can be the same color as any car next to it in line. Either car 5 or car 6 must be purple. Car 1 cannot be orange. Car 4 cannot be green.
Question:
The cars in which one of the following pairs CANNOT be the same color as each other?
Choices:
(A) cars 1 and 4
(B) cars 1 and 5
(C) cars 3 and 5
(D) cars 3 and 6
(E) cars 4 and 6
###"
"# Declarations
boats = EnumSort([Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, Valhalla])
arrived = Function([boats] -> [int])
ForAll([b:boats], And(1 <= arrived(b), arrived(b) <= 8))

# Constraints
Distinct([b:boats], arrived(b)) ::: no boat arrived at the same time as any other boat
And(arrived(Tornado) > arrived(Jewel), arrived(Tornado) < arrived(Spain)) ::: Tornado arrived before Spain but after Jewel
arrived(Neptune) < arrived(Tornado) ::: Neptune arrived before Tornado
arrived(Kashmir) > arrived(Jewel) ::: Kashmir arrived after Jewel
arrived(Spain) < arrived(Ojibwa) ::: Spain arrived before Ojibwa

# Options
Question ::: Of the eight boats, if Valhalla was the second to arrive, then which one of the following CANNOT be true?
is_exception(is_sat(arrived(Jewel) == 3)) ::: (A)
is_exception(is_sat(arrived(Jewel) == 1)) ::: (B)
is_exception(is_sat(arrived(Kashmir) == 3)) ::: (C)
is_exception(is_sat(arrived(Pacific) == 3)) ::: (D)
is_exception------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.
Question:
Of the eight boats, if Valhalla was the second to arrive, then which one of the following CANNOT be true?
Choices:
(A) Jewel was the third to arrive.
(B) Jewel was the first to arrive.
(C) Kashmir was the third to arrive.
(D) Pacific was the third to arrive.
(E) Tornado was the third to arrive.
###"
"# Declarations
boats = EnumSort([Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, Valhalla])
arrived = Function([boats] -> [int])
ForAll([b:boats], And(1 <= arrived(b), arrived(b) <= 8))

# Constraints
Distinct([b:boats], arrived(b)) ::: no boat arrived at the same time as any other boat
And(arrived(Tornado) > arrived(Jewel), arrived(Tornado) < arrived(Spain)) ::: Tornado arrived before Spain but after Jewel
arrived(Neptune) < arrived(Tornado) ::: Neptune arrived before Tornado
arrived(Kashmir) > arrived(Jewel) ::: Kashmir arrived after Jewel
arrived(Spain) < arrived(Ojibwa) ::: Spain arrived before Ojibwa

# Options
Question ::: If Valhalla arrived before Neptune but after Pacific, which one of the following could be true?
is_sat(And(arrived(Valhalla) > arrived(Pacific), arrived(Valhalla) < arrived(Neptune), arrived(Tornado) < arrived(Valhalla))) ::: (A)
is_sat(And(arrived(Valhalla) > arrived(Pacific), arrived(Valhalla) < arrived(Neptune), arrived(Kashmir) < arrived(Pacific))) ::: (B)
is_sat------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.
Question:
If Valhalla arrived before Neptune but after Pacific, which one of the following could be true?
Choices:
(A) Tornado arrived before Valhalla.
(B) Kashmir arrived before Pacific.
(C) Ojibwa was not the last of the boats to arrive.
(D) Spain arrived before Valhalla.
(E) Spain was not the seventh of the boats to arrive.
###"
"# Declarations
boats = EnumSort([Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, Valhalla])
arrived = Function([boats] -> [int])
ForAll([b:boats], And(1 <= arrived(b), arrived(b) <= 8))

# Constraints
Distinct([b:boats], arrived(b)) ::: no boat arrived at the same time as any other boat
And(arrived(Tornado) > arrived(Jewel), arrived(Tornado) < arrived(Spain)) ::: Tornado arrived before Spain but after Jewel
And(arrived(Neptune) < arrived(Tornado), arrived(Kashmir) > arrived(Jewel), arrived(Kashmir) < arrived(Spain)) ::: Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain.
And(arrived(Spain) < arrived(Ojibwa), arrived(Ojibwa) <= 8) ::: Spain arrived before Ojibwa.

# Options
Question ::: Of the boats, what are, respectively, the minimum number and the maximum number that could have arrived before Kashmir?
is_sat(Exists([b:boats], And(arrived(b) < arrived(Kashmir), arrived(b) == 1))) ::: (A)
is_sat(Exists([b:boats], And(arrived(b) < arrived(Kashmir), arrived(b) == 2))) ::: (B)
is_sat(Exists([b:boats], And(arrived(b) < arrived(Kashmir), arrived(b) == 3))) ::: (C)
is_sat(Exists([b:boats], And(arrived(b) < arrived(Kashmir), arrived(b) == 4))) ::: (D)
is_sat(Exists([b:boats], And(arrived(b) < arrived(Kashmir), arrived(b) == 5))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.
Question:
Of the boats, what are, respectively, the minimum number and the maximum number that could have arrived before Kashmir?
Choices:
(A) one, five
(B) two, five
(C) three, five
(D) one, six
(E) two, six
###"
"# Declarations
trees = EnumSort([firs, laurels, maples, oaks, pines, spruces, yews])
in_park = Function([trees] -> [bool])

# Constraints
ForAll([t:trees], Not(in_park(t))) ::: A park contains at most five of seven kinds of trees
Implies(in_park(maples), Not(in_park(yews))) ::: If maples are in the park, yews are not
Implies(in_park(firs), Not(in_park(pines))) ::: If firs are in the park, pines are not
Implies(Not(in_park(yews)), Or(in_park(laurels), in_park(oaks))) ::: If yews are not in the park, then either laurels or oaks, but not both, are in the park
Implies(Not(And(in_park(laurels), in_park(oaks))), And(in_park(firs), in_park(spruces))) ::: If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces

# Options
Question ::: If firs are not in the park, then which one of the following must be true?
is_valid(Not(in_park(maples))) ::: (A)
is_valid(Not(in_park(spruces))) ::: (B)
is_valid(Not(in_park(yews))) ::: (C)
is_valid(in_park(pines)) ::: (D)
is_valid(in_park(spruces)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.
Question:
If firs are not in the park, then which one of the following must be true?
Choices:
(A) Maples are not in the park.
(B) Spruces are not in the park.
(C) Yews are not in the park.
(D) Pines are in the park.
(E) Spruces are in the park.
###"
"# Declarations
council_members = EnumSort([Fu, Gianola, Herstein])
bills = EnumSort([recreation_bill, school_bill, tax_bill])
votes = Function([council_members, bills] -> [bool])

# Constraints
ForAll([m:council_members], Count([b:bills], votes(m, b)) >= 1) ::: Each member of the council votes for at least one of the bills
ForAll([m:council_members], Count([b:bills], Not(votes(m, b))) >= 1) ::: and against at least one of the bills
Count([m:council_members], votes(m, recreation_bill)) == 2 ::: Exactly two members of the council vote for the recreation bill
Count([m:council_members], votes(m, school_bill)) == 1 ::: Exactly one member of the council votes for the school bill
Count([m:council_members], votes(m, tax_bill)) == 1 ::: Exactly one member of the council votes for the tax bill
votes(Fu, recreation_bill) ::: Fu votes for the recreation bill
Not(votes(Gianola, recreation_bill)) ::: Gianola votes against the recreation bill
Not(votes(Herstein, tax_bill)) ::: Herstein votes against the tax bill

# Options
Question ::: If Gianola votes for the tax bill, then which one of the following statements could be true?
is_sat(And(votes(Gianola, tax_bill), Count([b:bills], votes(Fu, b)) == 1)) ::: A) Fu and Gianola each vote for exactly one bill.
is_sat(And(votes(Gianola, tax_bill), Count([b:bills], votes(Herstein, b)) == 1)) ::: B) Gianola and Herstein each vote for exactly one bill.
is_sat(And(votes(Gianola, tax_bill), Count([b:bills], votes(Fu, b)) == 2)) ::: C) Fu votes for exactly two bills.
is_sat(And(votes(Gianola, tax_bill), votes(Gianola, recreation_bill))) ::: D) Gianola votes for the recreation bill.
is_sat(And(votes(Gianola, tax_bill), Not(votes(Herstein, recreation_bill)))) ::: E) Herstein votes against the recreation bill.
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.
Question:
If Gianola votes for the tax bill, then which one of the following statements could be true?
Choices:
(A) Fu and Gianola each vote for exactly one bill.
(B) Gianola and Herstein each vote for exactly one bill.
(C) Fu votes for exactly two bills.
(D) Gianola votes for the recreation bill.
(E) Herstein votes against the recreation bill.
###"
"# Declarations
trains = EnumSort([Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, York])
arrives = Function([trains] -> [int])
ForAll([t:trains], 1 <= arrives(t) <= 7)

# Constraints
Distinct([t:trains], arrives(t)) ::: The trains arrive one at a time
Or(arrives(Wooster) == 4, arrives(York) == 4) ::: Either the York or the Wooster arrives fourth
And(arrives(Sunnydale) > arrives(Wooster), arrives(Sunnydale) < arrives(York)) ::: The Sunnydale arrives at some time after the Wooster but at some time before the York
And(arrives(Tilbury) > arrives(Rockville), arrives(Victoria) > arrives(Rockville)) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
Not(arrives(Tilbury) == arrives(Victoria) + 1) ::: The Tilbury does not arrive next after the Victoria
Not(arrives(Victoria) == arrives(Tilbury) + 1) ::: The Victoria does not arrive next after the Tilbury

# Options
Question ::: If the Wooster arrives at some time before the Rockville, then exactly how many different orders are there in which the seven trains could arrive?
is_sat(ForAll([t:trains], arrives(Wooster) < arrives(Rockville))) :::
is_sat(Count([t:trains], arrives(t) == 1) == 4) ::: (A)
is_sat(Count([t:trains], arrives(t) == 1) == 5) ::: (B)
is_sat(Count([t:trains], arrives(t) == 1) == 6) ::: (C)
is_sat(Count([t:trains], arrives(t) == 1) == 7) ::: (D)
is_sat(Count([t:trains], arrives(t) == 1) == 8) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.
Question:
If the Wooster arrives at some time before the Rockville, then exactly how many different orders are there in which the seven trains could arrive?
Choices:
(A) four
(B) five
(C) six
(D) seven
(E) eight
###"
"# Declarations
clowns = EnumSort([Q, R, S, T, V, W, Y, Z])
gets_out = Function([clowns] -> [int])
ForAll([c:clowns], And(1 <= gets_out(c), gets_out(c) <= 8))

# Constraints
Distinct([c:clowns], gets_out(c)) ::: no two clowns get out of the car at the same time
And(gets_out(V) < gets_out(Y), gets_out(V) < gets_out(Q)) ::: V gets out at some time before both Y and Q
gets_out(Q) > gets_out(Z) ::: Q gets out at some time after Z
And(gets_out(T) < gets_out(V), gets_out(T) > gets_out(R)) ::: T gets out at some time before V but at some time after R
gets_out(S) > gets_out(V) ::: S gets out at some time after V
gets_out(R) < gets_out(W) ::: R gets out at some time before W

# Options
Question ::: Which one of the following could be the order, from first to last, in which the clowns get out of the car?
is_sat(And(gets_out(T) == 1, gets_out(Z) == 2, gets_out(V) == 3, gets_out(R) == 4, gets_out(W) == 5, gets_out(Y) == 6, gets_out(S) == 7, gets_out(Q) == 8)) ::: (A)
is_sat(And(gets_out(Z) == 1, gets_out(R) == 2, gets_out(W) == 3, gets_out(Q) == 4, gets_out(T) == 5, gets_out(V) == 6, gets_out(Y) == 7, gets_out(S) == 8)) ::: (B)
is_sat(And(gets_out(R) == 1, gets_out(W) == 2, gets_out(T) == 3, gets_out(V) == 4, gets_out(Q) == 5, gets_out(Z) == 6, gets_out(S) == 7, gets_out(Y) == 8)) ::: (C)
is_sat(And(gets_out(Z) == 1, gets_out(W) == 2, gets_out(R) == 3, gets_out(T) == 4, gets_out(V) == 5, gets_out(Y) == 6, gets_out(Q) == 7, gets_out(S) == 8)) ::: (D)
is_sat(And(gets_out(R) == 1, gets_out(W) == 2, gets_out(T) == 3, gets_out(V) == 4, gets_out(Z) == 5, gets_out(S) == 6, gets_out(Y) == 7, gets_out(Q) == 8)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.
Question:
Which one of the following could be the order, from first to last, in which the clowns get out of the car?
Choices:
(A) T, Z, V, R, W, Y, S, Q
(B) Z, R, W, Q, T, V, Y, S
(C) R, W, T, V, Q, Z, S, Y
(D) Z, W, R, T, V, Y, Q, S
(E) R, W, T, V, Z, S, Y, Q
###"
"# Declarations
animals = EnumSort([F, G, H, K, L, N, T, V, Z])
selected = Function([animals] -> [bool])
ForAll([a:animals], selected(a) == True or selected(a) == False)

# Constraints
Not(And(selected(F), selected(H))) ::: F and H are not both selected
Not(And(selected(N), selected(T))) ::: N and T are not both selected
Implies(selected(H), selected(K)) ::: If H is selected, K is also selected
Implies(selected(K), selected(N)) ::: If K is selected, N is also selected

# Options
Question ::: Each of the following is a pair of animals that could be selected together EXCEPT
is_exception(is_sat(And(selected(F), selected(G)))) ::: (A)
is_exception(is_sat(And(selected(H), selected(K)))) ::: (B)
is_exception(is_sat(And(selected(K), selected(T)))) ::: (C)
is_exception(is_sat(And(selected(L), selected(N)))) ::: (D)
is_exception(is_sat(And(selected(T), selected(V)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.
Question:
Each of the following is a pair of animals that could be selected together EXCEPT
Choices:
(A) F and G
(B) H and K
(C) K and T
(D) L and N
(E) T and V
###"
"# Declarations
seats = EnumSort([1, 2, 3, 4, 5, 6])
athletes = EnumSort([Lee, Miller, Ovitz, Singh, Valerio, Zita])
rows = Function([athletes, seats] -> [bool])

# Constraints
ForAll([a:athletes], Count([s:seats], rows(a, s)) == 1) ::: each athlete rows at exactly one of the seats
And(rows(Miller, 1), rows(Singh, 2)) ::: Miller rows closer to the front than Singh
And(rows(Singh, 3), rows(Lee, 4), rows(Valerio, 5)) ::: Singh rows closer to the front than both Lee and Valerio
And(rows(Zita, 1), rows(Valerio, 2), rows(Ovitz, 3)) ::: Valerio and Zita each row closer to the front than Ovitz

# Options
Question ::: Which one of the following CANNOT be true?
is_exception(is_sat(rows(Ovitz, 1))) ::: A)
is_exception(is_sat(rows(Zita, 2))) ::: B)
is_exception(is_sat(rows(Lee, 3))) ::: C)
is_exception(is_sat(rows(Singh, 4))) ::: D)
is_exception(is_sat(rows(Valerio, 5))) ::: E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A rowing team uses a boat with exactly six seats arranged in single file and numbered sequentially 1 through 6, from the front of the boat to the back. Six athletes—Lee, Miller, Ovitz, Singh, Valerio, and Zita—each row at exactly one of the seats. The following restrictions must apply: Miller rows closer to the front than Singh. Singh rows closer to the front than both Lee and Valerio. Valerio and Zita each row closer to the front than Ovitz.
Question:
Which one of the following CANNOT be true?
Choices:
(A) Ovitz rows closer to the front than Singh.
(B) Zita rows closer to the front than Miller.
(C) Lee rows closer to the front than Valerio.
(D) Singh rows closer to the front than Zita.
(E) Valerio rows closer to the front than Lee.
###"
"# Declarations
committee = EnumSort([French, Ghauri, Hsia, Irving, Magnus, Pinsky])
subcommittees = EnumSort([subcommittee_1, subcommittee_2, subcommittee_3])
serves = Function([committee, subcommittees] -> [bool])

# Constraints
ForAll([c:committee], Count([s:subcommittees], serves(c, s)) >= 1) ::: Each committee member serves on at least one subcommittee
Exists([c:committee], ForAll([s:subcommittees], serves(c, s))) ::: One of the committee members serves on all three subcommittees
ForAll([s:subcommittees], Implies(serves(French, s), Not(serves(Ghauri, s)))) ::: French does not serve on any subcommittee with Ghauri
ForAll([s:subcommittees], Implies(serves(Hsia, s), Not(serves(Irving, s)))) ::: Hsia does not serve on any subcommittee with Irving

# Options
Question ::: Which one of the following must be true?
is_valid(ForAll([s:subcommittees], Or(serves(Ghauri, s), serves(Irving, s)))) ::: (A)
is_valid(ForAll([s:subcommittees], Implies(serves(Irving, s), Not(serves(Ghauri, s))))) ::: (B)
is_valid(ForAll([s:subcommittees], Or(serves(French, s), serves(Hsia, s)))) ::: (C)
is_valid(ForAll([s:subcommittees], Or(serves(Ghauri, s), serves(Irving, s)))) ::: (D)
is_valid(ForAll([s:subcommittees], Or(serves(Magnus, s), serves(Pinsky, s)))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A reporter is trying to uncover the workings of a secret committee. The committee has six members—French, Ghauri, Hsia, Irving, Magnus, and Pinsky—each of whom serves on at least one subcommittee. There are three subcommittees, each having three members, about which the following is known: One of the committee members serves on all three subcommittees. French does not serve on any subcommittee with Ghauri. Hsia does not serve on any subcommittee with Irving.
Question:
Which one of the following must be true?
Choices:
(A) Ghauri serves on at least two subcommittees.
(B) Irving serves on only one subcommittee.
(C) French serves on a subcommittee with Hsia.
(D) Ghauri serves on a subcommittee with Irving.
(E) Magnus serves on a subcommittee with Pinsky.
###"
"# Declarations
courses = EnumSort([geography, history, literature, mathematics, psychology, sociology, zoology])
offered = Function([courses] -> [bool])

# Constraints
ForAll([c:courses], offered(c) == True) ::: The following restrictions on the program must apply
Implies(offered(mathematics), Or(offered(literature), offered(sociology))) ::: If mathematics is offered, then either literature or sociology (but not both) is offered
Implies(offered(literature), And(offered(geography), Not(offered(psychology)))) ::: If literature is offered, then geography is also offered but psychology is not
Implies(offered(sociology), And(offered(psychology), Not(offered(zoology)))) ::: If sociology is offered, then psychology is also offered but zoology is not
Implies(offered(geography), And(offered(history), offered(zoology))) ::: If geography is offered, then both history and zoology are also offered

# Options
Question ::: Which one of the following could be a complete and accurate list of the courses offered by the summer program?
is_valid(And(offered(history), offered(psychology))) ::: (A)
is_valid(And(offered(geography), offered(history), offered(literature))) ::: (B)
is_valid(And(offered(history), offered(mathematics), offered(psychology))) ::: (C)
is_valid(And(offered(literature), offered(mathematics), offered(psychology))) ::: (D)
is_valid(And(offered(history), offered(literature), offered(mathematics), offered(sociology))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A summer program offers at least one of the following seven courses: geography, history, literature, mathematics, psychology, sociology, zoology. The following restrictions on the program must apply: If mathematics is offered, then either literature or sociology (but not both) is offered. If literature is offered, then geography is also offered but psychology is not. If sociology is offered, then psychology is also offered but zoology is not. If geography is offered, then both history and zoology are also offered.
Question:
Which one of the following could be a complete and accurate list of the courses offered by the summer program?
Choices:
(A) history, psychology
(B) geography, history, literature
(C) history, mathematics, psychology
(D) literature, mathematics, psychology
(E) history, literature, mathematics, sociology
###"
"# Declarations
courses = EnumSort([geography, history, literature, mathematics, psychology, sociology, zoology])
offered = Function([courses] -> [bool])

# Constraints
ForAll([c:courses], offered(c) == True) ::: The following restrictions on the program must apply
Implies(offered(mathematics), Or(offered(literature), offered(sociology))) ::: If mathematics is offered, then either literature or sociology (but not both) is offered
Implies(offered(literature), And(offered(geography), Not(offered(psychology)))) ::: If literature is offered, then geography is also offered but psychology is not
Implies(offered(sociology), And(offered(psychology), Not(offered(zoology)))) ::: If sociology is offered, then psychology is also offered but zoology is not
Implies(offered(geography), And(offered(history), offered(zoology))) ::: If geography is offered, then both history and zoology are also offered

# Options
Question ::: If history is not offered by the summer program, then which one of the following is another course that CANNOT be offered?
is_exception(is_sat(offered(history) == False)) ::: (A)
is_exception(is_sat(offered(literature) == False)) ::: (B)
is_exception(is_sat(offered(mathematics) == False)) ::: (C)
is_exception(is_sat(offered(psychology) == False)) ::: (D)
is_exception(is_sat(offered(sociology) == False)) ::: (E)
is_exception(is_sat(offered(zoology) == False)) ::: (F)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A summer program offers at least one of the following seven courses: geography, history, literature, mathematics, psychology, sociology, zoology. The following restrictions on the program must apply: If mathematics is offered, then either literature or sociology (but not both) is offered. If literature is offered, then geography is also offered but psychology is not. If sociology is offered, then psychology is also offered but zoology is not. If geography is offered, then both history and zoology are also offered.
Question:
If history is not offered by the summer program, then which one of the following is another course that CANNOT be offered?
Choices:
(A) literature
(B) mathematics
(C) psychology
(D) sociology
(E) zoology
###"
"# Declarations
chips = EnumSort([F, G, H, J, K, L, M, O])
rank = Function([chips] -> [int])
ForAll([c:chips], 1 <= rank(c) <= 8)

# Constraints
Distinct([c:chips], rank(c)) ::: There are no ties
Or(rank(F) == 1, rank(G) == 1) ::: Either F or G is ranked first
rank(M)!= 8 ::: M is not the slowest
And(rank(H) < rank(J), rank(J) - rank(H) == 1) ::: H is faster than J, with exactly one chip intermediate in speed between them
And(rank(K) < rank(L), rank(L) - rank(K) == 2) ::: K is faster than L, with exactly two chips intermediate in speed between them
And(rank(O) > rank(J), rank(O) > rank(L)) ::: O is slower than both J and L

# Options
Question ::: Which one of the following could be true?
is_sat(And(rank(F) == 1, rank(M) == 8)) ::: (A)
is_sat(And(rank(G) == 5, rank(O) == 8)) ::: (B)
is_sat(And(rank(J) == 3, rank(L) == 7)) ::: (C)
is_sat(And(rank(K) == 2, rank(H) == 3)) ::: (D)
is_sat(And(rank(M) == 7, rank(L) == 8)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Exactly eight computer processor chips—F, G, H, J, K, L, M, and O—are ranked according to their speed from first (fastest) to eighth (slowest). The ranking must be consistent with the following: There are no ties. Either F or G is ranked first. M is not the slowest. H is faster than J, with exactly one chip intermediate in speed between them. K is faster than L, with exactly two chips intermediate in speed between them. O is slower than both J and L.
Question:
Which one of the following could be true?
Choices:
(A) F is ranked first and M is ranked eighth.
(B) G is ranked fifth and O is ranked eighth.
(C) J is ranked third and L is ranked seventh.
(D) K is ranked second and H is ranked third.
(E) M is ranked seventh and L is ranked eighth.
###"
"# Declarations
people = EnumSort([F, G, H, K, L, M, U, W, X, Z])
committee = Function([people] -> [bool])

# Constraints
ForAll([p:people], Not(committee(p))) ::: no one is selected
ForAll([p:people], Implies(committee(p), p!= F)) ::: The committee must include exactly one student
And(Not(committee(F)), Not(committee(H))) ::: F and H cannot both be selected
And(Not(committee(M)), Not(committee(Z))) ::: M and Z cannot both be selected
And(Not(committee(U)), Not(committee(W))) ::: U and W cannot both be selected
ForAll([p:people], Implies(committee(F), committee(Z))) ::: F cannot be selected unless Z is also selected
ForAll([p:people], Implies(committee(W), committee(H))) ::: W cannot be selected unless H is also selected

# Options
Question ::: If W is selected, then any one of the following could also be selected EXCEPT:
is_exception(is_sat(committee(F))) ::: (A)
is_exception(is_sat(committee(G))) ::: (B)
is_exception(is_sat(committee(L))) ::: (C)
is_exception(is_sat(committee(M))) ::: (D)
is_exception(is_sat(committee(Z))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
The members of a five-person committee will be selected from among three parents—F, G, and H—three students—K, L, and M—and four teachers—U, W, X, and Z. The selection of committee members will meet the following conditions: The committee must include exactly one student. F and H cannot both be selected. M and Z cannot both be selected. U and W cannot both be selected. F cannot be selected unless Z is also selected. W cannot be selected unless H is also selected.
Question:
If W is selected, then any one of the following could also be selected EXCEPT:
Choices:
(A) F
(B) G
(C) L
(D) M
(E) Z
###"
"# Declarations
parcels = EnumSort([G, H, J, K, L, M, N, O])
delivered = Function([parcels] -> [int])
ForAll([p:parcels], And(1 <= delivered(p), delivered(p) <= 8))

# Constraints
Distinct([p:parcels], delivered(p)) ::: no two parcels are delivered at the same time
And(delivered(L) > delivered(H), delivered(K) < delivered(O), delivered(H) < delivered(M), delivered(O) > delivered(G), delivered(M) < delivered(G), And(delivered(N) < delivered(M), delivered(J) < delivered(M))) ::: L is delivered later than H. K is delivered earlier than O. H is delivered earlier than M. O is delivered later than G. M is delivered earlier than G. Both N and J are delivered earlier than M.

# Options
Question ::: Each of the following could be true EXCEPT:
is_exception(is_sat(delivered(H) > delivered(K))) ::: (A)
is_exception(is_sat(delivered(J) > delivered(G))) ::: (B)
is_exception(is_sat(delivered(L) > delivered(O))) ::: (C)
is_exception(is_sat(delivered(M) > delivered(L))) ::: (D)
is_exception(is_sat(delivered(N) > delivered(H))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A courier delivers exactly eight parcels—G, H, J, K, L, M, N, and O. No two parcels are delivered at the same time, nor is any parcel delivered more than once. The following conditions must apply: L is delivered later than H. K is delivered earlier than O. H is delivered earlier than M. O is delivered later than G. M is delivered earlier than G. Both N and J are delivered earlier than M.
Question:
Each of the following could be true EXCEPT:
Choices:
(A) H is delivered later than K.
(B) J is delivered later than G.
(C) L is delivered later than O.
(D) M is delivered later than L.
(E) N is delivered later than H.
###"
"# Declarations
weeks = EnumSort([1, 2, 3, 4, 5, 6, 7])
destinations = EnumSort([Guadeloupe, Jamaica, Martinique, Trinidad])
voyages = Function([weeks, destinations] -> [bool])

# Constraints
ForAll([d:destinations], Exists([w:weeks], voyages(w, d))) ::: Each destination will be scheduled for at least one of the weeks
Not(voyages(4, Jamaica)) ::: Jamaica will not be its destination in week 4
voyages(7, Trinidad) ::: Trinidad will be its destination in week 7
Count([w:weeks], voyages(w, Martinique)) == 2 ::: Freedom will make exactly two voyages to Martinique
Exists([w:weeks], And(w!= 7, voyages(w, Guadeloupe), voyages(w + 1, Jamaica))) ::: at least one voyage to Guadeloupe will occur in some week between those two voyages
ForAll([w:weeks], Not(voyages(w, Guadeloupe), voyages(w + 1, Guadeloupe))) ::: No destination will be scheduled for consecutive weeks

# Options
Question ::: Which one of the following CANNOT be true about Freedom's schedule of voyages?
is_exception(is_sat(voyages(6, Trinidad))) ::: (A)
is_exception(is_sat(voyages(5, Martinique))) ::: (B)
is_exception(is_sat(voyages(6, Jamaica)))------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A cruise line is scheduling seven week-long voyages for the ship Freedom. Each voyage will occur in exactly one of the first seven weeks of the season: weeks 1 through 7. Each voyage will be to exactly one of four destinations: Guadeloupe, Jamaica, Martinique, or Trinidad. Each destination will be scheduled for at least one of the weeks. The following conditions apply to Freedom's schedule: Jamaica will not be its destination in week 4. Trinidad will be its destination in week 7. Freedom will make exactly two voyages to Martinique, and at least one voyage to Guadeloupe will occur in some week between those two voyages. Guadeloupe will be its destination in the week preceding any voyage it makes to Jamaica. No destination will be scheduled for consecutive weeks.
Question:
Which one of the following CANNOT be true about Freedom's schedule of voyages?
Choices:
(A) Freedom makes a voyage to Trinidad in week 6.
(B) Freedom makes a voyage to Martinique in week 5.
(C) Freedom makes a voyage to Jamaica in week 6.
(D) Freedom makes a voyage to Jamaica in week 3.
(E) Freedom makes a voyage to Guadeloupe in week 3.
###"
"# Declarations
children = EnumSort([Juana, Kyle, Lucita, Salim, Thanh, Veronica])
adults = EnumSort([Ms_Margoles, Mr_O_Connell, Ms_Podorski])
accompanies = Function([children, adults] -> [bool])

# Constraints
ForAll([a:adults], Count([c:children], accompanies(c, a)) == 2) ::: Each adult accompanies exactly two of the children
ForAll([c:children], Count([a:adults], accompanies(c, a)) == 1) ::: Each child is accompanied by one of three adults
ForAll([c:children], Implies(accompanies(Juana, Ms_Margoles), accompanies(Lucita, Ms_Podorski))) ::: If Ms. Margoles accompanies Juana, then Ms. Podorski accompanies Lucita
ForAll([c:children], Implies(Not(accompanies(Kyle, Ms_Margoles)), accompanies(Veronica, Mr_O_Connell))) ::: If Kyle is not accompanied by Ms. Margoles, then Veronica is accompanied by Mr. O'Connell
Or(accompanies(Thanh, Ms_Margoles), accompanies(Thanh, Mr_O_Connell)) ::: Either Ms. Margoles or Mr. O'Connell accompanies Thanh
ForAll([c:children], Implies(accompanies(c, Ms_Margoles), Not(accompanies(c, Mr_O_Connell)))) ::: Juana is not accompanied by the same adult as Kyle
ForAll([c:children], Implies(accompanies(c, Ms_Margoles), Not(accompanies(c, Ms_Podorski)))) ::: Lucita is not accompanied by the same adult as Salim
ForAll([c:children], Implies(accompanies(c, Ms_Margoles), Not(accompanies(c, Mr_O_Connell)))) ::: Thanh is not accompanied by the same adult as Veronica

# Options
Question ::: If Ms. Podorski accompanies Juana and Veronica, then Ms. Margoles could accompany which one of the following pairs of children?
is_sat(And(accompanies(Juana, Ms_Podorski), accompanies(Veronica, Ms_Podorski), accompanies(Kyle, Ms_Margoles), accompanies(Salim, Ms_Margoles))) ::: (A)
is_sat(And(accompanies(Juana, Ms_Podorski), accompanies(Veronica, Ms_Podorski), accompanies(Kyle, Ms_Margoles), accompanies(Thanh, Ms_Margoles))) ::: (B)
is_sat(And(accompanies(Juana, Ms_Podorski), accompanies(Veronica, Ms_Podorski), accompanies(Lucita, Ms_Margoles), accompanies(Salim, Ms_Margoles))) ::: (C)
is_sat(And(accompanies(Juana, Ms_Podorski), accompanies(Veronica, Ms_Podorski), accompanies(Lucita, Ms_Margoles), accompanies(Thanh, Ms_Margoles))) ::: (D)
is_sat(And(accompanies(Juana, Ms_Podorski), accompanies(Veronica, Ms_Podorski), accompanies(Salim, Ms_Margoles), accompanies(Thanh, Ms_Margoles))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
On a field trip to the Museum of Natural History, each of six children—Juana, Kyle, Lucita, Salim, Thanh, and Veronica—is accompanied by one of three adults—Ms. Margoles, Mr. O'Connell, and Ms. Podorski. Each adult accompanies exactly two of the children, consistent with the following conditions: If Ms. Margoles accompanies Juana, then Ms. Podorski accompanies Lucita. If Kyle is not accompanied by Ms. Margoles, then Veronica is accompanied by Mr. O'Connell. Either Ms. Margoles or Mr. O'Connell accompanies Thanh. Juana is not accompanied by the same adult as Kyle; nor is Lucita accompanied by the same adult as Salim; nor is Thanh accompanied by the same adult as Veronica.
Question:
If Ms. Podorski accompanies Juana and Veronica, then Ms. Margoles could accompany which one of the following pairs of children?
Choices:
(A) Kyle and Salim
(B) Kyle and Thanh
(C) Lucita and Salim
(D) Lucita and Thanh
(E) Salim and Thanh
###"
"# Declarations
restaurants = EnumSort([Figueroa, Ginsberg, Harris, Kanzaki, Leacock, Malpighi])
deliveries = Function([restaurants] -> [int])
ForAll([r:restaurants], And(1 <= deliveries(r), deliveries(r) <= 6))

# Constraints
And(deliveries(Ginsberg) > deliveries(Figueroa), deliveries(Ginsberg) < deliveries(Kanzaki)) ::: Ginsberg's delivery is earlier than Kanzaki's but later than Figueroa's
deliveries(Harris) < deliveries(Ginsberg) ::: Harris's delivery is earlier than Ginsberg's
Implies(deliveries(Figueroa) < deliveries(Malpighi), deliveries(Leacock) < deliveries(Harris)) ::: If Figueroa's delivery is earlier than Malpighi's, then Leacock's delivery is earlier than Harris's
Or(deliveries(Malpighi) < deliveries(Harris), deliveries(Malpighi) > deliveries(Kanzaki)) ::: Either Malpighi's delivery is earlier than Harris's or it is later than Kanzaki's, but not both

# Options
Question ::: Which one of the following accurately represents an order in which the deliveries could occur, from first to last?
is_sat(And(deliveries(Harris) == 1, deliveries(Figueroa) == 2, deliveries(Leacock) == 3, deliveries(Ginsberg) == 4, deliveries(Malpighi) == 5, deliveries(Kanzaki) == 6)) ::: (A)
is_sat(And(deliveries(Leacock) == 1, deliveries(Harris) == 2, deliveries(Figueroa) == 3, deliveries(Ginsberg) == 4, deliveries(Malpighi) == 5, deliveries(Kanzaki) == 6)) ::: (B)
is_sat(And(deliveries(Malpighi) == 1, deliveries(Figueroa) == 2, deliveries(Harris) == 3, deliveries(Ginsberg) == 4, deliveries(Leacock) == 5, deliveries(Kanzaki) == 6)) ::: (C)
is_sat(And(deliveries(Malpighi) == 1, deliveries(Figueroa) == 2, deliveries(Kanzaki) == 3, deliveries(Harris) == 4, deliveries(Ginsberg) == 5, deliveries(Leacock) == 6)) ::: (D)
is_sat(And(deliveries(Malpighi) == 1, deliveries(Figueroa) == 2, deliveries(Ginsberg) == 3, deliveries(Kanzaki) == 4, deliveries(Harris) == 5, deliveries(Leacock) == 6)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A bread truck makes exactly one bread delivery to each of six restaurants in succession—Figueroa's, Ginsberg's, Harris's, Kanzaki's, Leacock's, and Malpighi's—though not necessarily in that order. The following conditions must apply: Ginsberg's delivery is earlier than Kanzaki's but later than Figueroa's. Harris's delivery is earlier than Ginsberg's. If Figueroa's delivery is earlier than Malpighi's, then Leacock's delivery is earlier than Harris's. Either Malpighi's delivery is earlier than Harris's or it is later than Kanzaki's, but not both.
Question:
Which one of the following accurately represents an order in which the deliveries could occur, from first to last?
Choices:
(A) Harris's, Figueroa's, Leacock's, Ginsberg's, Kanzaki's, Malpighi's
(B) Leacock's, Harris's, Figueroa's, Ginsberg's, Malpighi's, Kanzaki's
(C) Malpighi's, Figueroa's, Harris's, Ginsberg's, Leacock's, Kanzaki's
(D) Malpighi's, Figueroa's, Kanzaki's, Harris's, Ginsberg's, Leacock's
(E) Malpighi's, Figueroa's, Ginsberg's, Kanzaki's, Harris's, Leacock's
###"
"# Declarations
architects = EnumSort([Green, Jackson, Liu, Mertz, Peete, Valdez])
designs = EnumSort([Green_design, Jackson_design, Liu_design, Mertz_design, Peete_design, Valdez_design])
presented = Function([designs] -> [int])
ForAll([d:designs], And(1 <= presented(d), presented(d) <= 6))

# Constraints
Distinct([d:designs], presented(d)) ::: each design being presented exactly once
And(presented(Mertz_design) < presented(Liu_design), presented(Mertz_design) > presented(Peete_design)) ::: Mertz's design is presented at some time before Liu's and after Peete's
Or(And(presented(Green_design) < presented(Jackson_design), Not(presented(Green_design) > presented(Liu_design))), And(presented(Green_design) > presented(Liu_design), Not(presented(Green_design) < presented(Jackson_design)))) ::: Green's design is presented either at some time before Jackson's or at some time after Liu's, but not both
Or(And(presented(Valdez_design) < presented(Green_design), Not(presented(Valdez_design) > presented(Peete_design))), And(presented(Valdez_design) > presented(Peete_design), Not(presented(Valdez_design) < presented(Green_design)))) ::: Valdez's design is presented either at some time before Green's or at some time after Peete's, but not both

# Options
Question ::: If Liu's design is presented sixth, then which one of the following must be true?
is_sat(presented(Green_design) < presented(Jackson_design)) ::: (A)
is_sat(presented(Jackson_design) < presented(Mertz_design)) ::: (B------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A competition is being held to select a design for Yancy College's new student union building. Each of six architects—Green, Jackson, Liu, Mertz, Peete, and Valdez—has submitted exactly one design. There are exactly six designs, and they are presented one at a time to the panel of judges, each design being presented exactly once, consistent with the following conditions: Mertz's design is presented at some time before Liu's and after Peete's. Green's design is presented either at some time before Jackson's or at some time after Liu's, but not both. Valdez's design is presented either at some time before Green's or at some time after Peete's, but not both.
Question:
If Liu's design is presented sixth, then which one of the following must be true?
Choices:
(A) Green's design is presented at some time before Jackson's.
(B) Jackson's design is presented at some time before Mertz's.
(C) Peete's design is presented at some time before Green's.
(D) Peete's design is presented at some time before Valdez's.
(E) Valdez's design is presented at some time before Green's.
###"
"# Declarations
cds = EnumSort([Headstrong, In_Flight, Nice, Quasi, Reunion, Sounds_Good])
ratings = EnumSort([one, two, three, four])
received = Function([cds, ratings] -> [bool])

# Constraints
ForAll([r:ratings], Count([c:cds], received(c, r)) >= 1) ::: For each of the ratings, at least one but no more than two of the CDs received that rating
And(Count([c:cds], received(c, four)) == 1, Count([c:cds], received(c, three)) == 2) ::: Headstrong received exactly one more star than Nice did
Or(And(received(Headstrong, four), received(Reunion, three)), And(received(Headstrong, three), received(Reunion, four))) ::: Either Headstrong or Reunion received the same number of stars as In Flight did
Count([c:cds], received(c, four)) <= 1 ::: At most one CD received more stars than Quasi did

# Options
Question ::: Which one of the following CANNOT have received a rating of four stars?
is_exception(is_sat(received(Headstrong, four))) ::: (A)
is_exception(is_sat(received(In_Flight, four))) ::: (B)
is_exception(is_sat(received(Quasi, four))) ::: (C)
is_exception(is_sat(received(Reunion, four))) ::: (D)
is_exception(is_sat(received(Sounds_Good, four))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A critic has prepared a review of exactly six music CDs—Headstrong, In Flight, Nice, Quasi, Reunion, and Sounds Good. Each CD received a rating of either one, two, three, or four stars, with each CD receiving exactly one rating. Although the ratings were meant to be kept secret until the review was published, the following facts have been leaked to the public: For each of the ratings, at least one but no more than two of the CDs received that rating. Headstrong received exactly one more star than Nice did. Either Headstrong or Reunion received the same number of stars as In Flight did. At most one CD received more stars than Quasi did.
Question:
Which one of the following CANNOT have received a rating of four stars?
Choices:
(A) Headstrong
(B) In Flight
(C) Quasi
(D) Reunion
(E) Sounds Good
###"
"# Declarations
people = EnumSort([Grace, Heather, Josh, Maria])
furnitures = EnumSort([recliner, sofa, table])
moves = Function([people, furnitures] -> [bool])

# Constraints
ForAll([p:people], Exists([f:furnitures], moves(p, f))) ::: each person will help move at least one of the pieces of furniture
ForAll([f:furnitures], Count([p:people], moves(p, f)) == 2) ::: Each piece of furniture will be moved by exactly two of the people
And(moves(Grace, sofa), moves(Heather, recliner)) ::: Grace helps move the sofa if, but only if, Heather helps move the recliner
And(moves(Josh, table), moves(Maria, recliner)) ::: If Josh helps move the table, then Maria helps move the recliner
ForAll([f:furnitures], Not(moves(Grace, f), moves(Josh, f))) ::: No piece of furniture is moved by Grace and Josh together

# Options
Question ::: Which one of the following could be an accurate matching of each piece of furniture to the two people who help each other move it?
is_valid(And(moves(Grace, recliner), moves(Maria, recliner), moves(Heather, sofa), moves(Josh, sofa), moves(Grace, table), moves(Heather, table))) ::: (A)
is_valid(And(moves(Grace, recliner), moves(Maria, recliner), moves(Heather, sofa), moves(Maria, sofa), moves(Grace, table), moves(Heather, table))) ::: (B)
is_valid(And(moves(Heather, recliner), moves(Josh, recliner), moves(Grace, sofa), moves(Heather, sofa), moves(Josh, table), moves(Maria, table))) ::: (C)
is_valid(And(moves(Heather, recliner), moves(Josh, recliner), moves(Heather, sofa), moves(Maria, sofa), moves(Grace, table), moves(Maria, table))) ::: (D)
is_valid(And(moves(Josh, recliner), moves(Maria, recliner), moves(Grace, sofa), moves(Heather, sofa), moves(Grace, table), moves(Maria, table))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Four people—Grace, Heather, Josh, and Maria—will help each other move exactly three pieces of furniture—a recliner, a sofa, and a table. Each piece of furniture will be moved by exactly two of the people, and each person will help move at least one of the pieces of furniture, subject to the following constraints: Grace helps move the sofa if, but only if, Heather helps move the recliner. If Josh helps move the table, then Maria helps move the recliner. No piece of furniture is moved by Grace and Josh together.
Question:
Which one of the following could be an accurate matching of each piece of furniture to the two people who help each other move it?
Choices:
(A) recliner: Grace and Maria; sofa: Heather and Josh; table: Grace and Heather
(B) recliner: Grace and Maria; sofa: Heather and Maria; table: Grace and Josh
(C) recliner: Heather and Josh; sofa: Grace and Heather; table: Josh and Maria
(D) recliner: Heather and Josh; sofa: Heather and Maria; table: Grace and Maria
(E) recliner: Josh and Maria; sofa: Grace and Heather; table: Grace and Maria
###"
"# Declarations
employees = EnumSort([Felicia, Leah, Masatomo, Rochelle, Salman, Terry, Veena])
volunteers = Function([employees] -> [bool])

# Constraints
ForAll([e:employees], volunteers(e) == True or volunteers(e) == False)
Implies(volunteers(Rochelle), volunteers(Masatomo)) ::: If Rochelle volunteers, then so does Masatomo.
Implies(volunteers(Masatomo), volunteers(Terry)) ::: If Masatomo volunteers, then so does Terry.
Implies(Not(volunteers(Salman)), volunteers(Veena)) ::: If Salman does not volunteer, then Veena volunteers.
Implies(Not(volunteers(Rochelle)), volunteers(Leah)) ::: If Rochelle does not volunteer, then Leah volunteers.
Implies(volunteers(Terry), And(Not(volunteers(Felicia)), Not(volunteers(Veena)))) ::: If Terry volunteers, then neither Felicia nor Veena volunteers.

# Options
Question ::: If Felicia volunteers, then which one of the following must be true?
is_valid(volunteers(Leah)) ::: (A)
is_valid(volunteers(Salman)) ::: (B)
is_valid(Not(volunteers(Veena))) ::: (C)
is_valid(Count([e:employees], volunteers(e)) == 3) ::: (D)
is_valid(Count([e:employees], volunteers(e)) == 4) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A company organizing on-site day care consults with a group of parents composed exclusively of volunteers from among the seven employees—Felicia, Leah, Masatomo, Rochelle, Salman, Terry, and Veena—who have become parents this year. The composition of the volunteer group must be consistent with the following: If Rochelle volunteers, then so does Masatomo. If Masatomo volunteers, then so does Terry. If Salman does not volunteer, then Veena volunteers. If Rochelle does not volunteer, then Leah volunteers. If Terry volunteers, then neither Felicia nor Veena volunteers.
Question:
If Felicia volunteers, then which one of the following must be true?
Choices:
(A) Leah volunteers.
(B) Salman volunteers.
(C) Veena does not volunteer.
(D) Exactly three of the employees volunteer.
(E) Exactly four of the employees volunteer.
###"
"# Declarations
courses = EnumSort([history, linguistics, music, physics, statistics, theater, writing])
takes = Function([courses] -> [bool])

# Constraints
ForAll([c:courses], Implies(takes(c), Count([c:courses], takes(c)) >= 3)) ::: Each summer school student must take at least three courses from among the following seven
ForAll([c:courses], Implies(takes(history), And(Not(takes(statistics)), Not(takes(music))))) ::: If history is taken, then neither statistics nor music can be taken
ForAll([c:courses], Implies(takes(music), And(Not(takes(physics)), Not(takes(theater))))) ::: If music is taken, then neither physics nor theater can be taken
ForAll([c:courses], Implies(takes(writing), And(Not(takes(physics)), Not(takes(statistics))))) ::: If writing is taken, then neither physics nor statistics can be taken

# Options
Question ::: What is the maximum number of courses the student could take during the summer school session?
is_sat(Count([c:courses], takes(c)) == 7) ::: (A)
is_sat(Count([c:courses], takes(c)) == 6) ::: (B)
is_sat(Count([c:courses], takes(c)) == 5) ::: (C)
is_sat(Count([c:courses], takes(c)) == 4) ::: (D)
is_sat(Count([c:courses], takes(c)) == 3) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A student is choosing courses to take during a summer school session. Each summer school student must take at least three courses from among the following seven: history, linguistics, music, physics, statistics, theater, and writing. The summer school schedule restricts the courses a student can take in the following ways: If history is taken, then neither statistics nor music can be taken. If music is taken, then neither physics nor theater can be taken. If writing is taken, then neither physics nor statistics can be taken.
Question:
What is the maximum number of courses the student could take during the summer school session?
Choices:
(A) seven
(B) six
(C) five
(D) four
(E) three
###"
"# Declarations
courses = EnumSort([history, linguistics, music, physics, statistics, theater, writing])
takes = Function([courses] -> [bool])

# Constraints
ForAll([c:courses], Implies(takes(c), Count([c:courses], takes(c)) >= 3)) ::: Each summer school student must take at least three courses from among the following seven
ForAll([c:courses], Implies(takes(history), And(Not(takes(statistics)), Not(takes(music))))) ::: If history is taken, then neither statistics nor music can be taken
ForAll([c:courses], Implies(takes(music), And(Not(takes(physics)), Not(takes(theater))))) ::: If music is taken, then neither physics nor theater can be taken
ForAll([c:courses], Implies(takes(writing), And(Not(takes(physics)), Not(takes(statistics))))) ::: If writing is taken, then neither physics nor statistics can be taken

# Options
Question ::: If the student takes music, then which one of the following must the student also take?
is_valid(Implies(takes(music), takes(writing))) ::: (A)
is_valid(Implies(takes(music), takes(theater))) ::: (B)
is_valid(Implies(takes(music), takes(statistics))) ::: (C)
is_valid(Implies(takes(music), takes(physics))) ::: (D)
is_valid(Implies(takes(music), takes(linguistics))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A student is choosing courses to take during a summer school session. Each summer school student must take at least three courses from among the following seven: history, linguistics, music, physics, statistics, theater, and writing. The summer school schedule restricts the courses a student can take in the following ways: If history is taken, then neither statistics nor music can be taken. If music is taken, then neither physics nor theater can be taken. If writing is taken, then neither physics nor statistics can be taken.
Question:
If the student takes music, then which one of the following must the student also take?
Choices:
(A) writing
(B) theater
(C) statistics
(D) physics
(E) linguistics
###"
"# Declarations
departments = EnumSort([family_law, health_law, injury_law, labor_law, probate, securities, tax_law])
floors = EnumSort([bottom_floor, middle_floor, top_floor])
assigned = Function([departments, floors] -> [bool])

# Constraints
ForAll([d:departments], Count([f:floors], assigned(d, f)) <= 1) ::: no department is to be on more than one floor
ForAll([f:floors], Count([d:departments], assigned(d, f)) <= 4) ::: each floor can accommodate up to four departments
And(assigned(probate, middle_floor), assigned(tax_law, middle_floor)) ::: Probate must be on the same floor as tax law
assigned(health_law, middle_floor) ::: Health law must be on the floor immediately above injury law
assigned(labor_law, bottom_floor) ::: Labor law must occupy an entire floor by itself

# Options
Question ::: If injury law and probate are both assigned to the middle floor, which one of the following could be true?
is_sat(assigned(family_law, middle_floor)) ::: (A)
is_sat(assigned(health_law, middle_floor)) ::: (B)
is_sat(assigned(labor_law, top_floor)) ::: (C)
is_sat(assigned(securities, bottom_floor)) ::: (D)
is_sat(assigned(tax_law, top_floor)) ::: (------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A law firm has seven departments—family law, health law, injury law, labor law, probate, securities, and tax law. The firm is to occupy a building with three floors—the bottom floor, the middle floor, and the top floor. Each floor can accommodate up to four departments, and no department is to be on more than one floor. Assignment of departments to floors is subject to the following constraints: Probate must be on the same floor as tax law. Health law must be on the floor immediately above injury law. Labor law must occupy an entire floor by itself.
Question:
If injury law and probate are both assigned to the middle floor, which one of the following could be true?
Choices:
(A) Family law is assigned to the middle floor.
(B) Health law is assigned to the middle floor.
(C) Labor law is assigned to the top floor.
(D) Securities is assigned to the bottom floor.
(E) Tax law is assigned to the top floor.
###"
"# Declarations
courses = EnumSort([Geography, Japanese, Macroeconomics, Psychology, Russian, Statistics, WorldHistory])
takes = Function([courses] -> [bool])

# Constraints
ForAll([c:courses], takes(c) == False) ::: no one is allowed to take any course more than once per semester
Implies(Not(takes(Russian)), takes(Japanese)) ::: She must take Japanese if she does not take Russian
Implies(takes(Macroeconomics), Not(takes(Japanese))) ::: She cannot take Japanese if she takes Macroeconomics
Implies(takes(WorldHistory), Not(takes(Statistics))) ::: She cannot take World History if she takes Statistics at 9 A.M.
Implies(takes(Psychology), takes(Statistics)) ::: She must take Statistics at 9 A.M. if she takes Psychology
Or(takes(Geography), takes(WorldHistory)) ::: She must take either Geography or World History but cannot take both

# Options
Question ::: Suppose that Alicia must take Statistics if she takes Psychology, but rather than being restricted to taking Statistics at 9 A.M. she can take it at either 9 A.M. or at 3 P.M. If all the other restrictions remain the same, then which one of the following could be the list of the four courses Alicia takes?
is_valid(And(takes(Psychology), takes(Statistics))) ::: (A)
is_valid(And(takes(Macroeconomics), takes(Psychology), takes(Statistics))) ::: (B)
is_valid(And(takes(Macroeconomics), takes(Psychology), takes(Russian))) ::: (C)
is_valid(And(takes(Geography), takes(Psychology), takes(Russian))) ::: (D)
is_valid(And(takes(Geography), takes(Macroeconomics), takes(Russian))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Alicia will take exactly four courses this semester. She must choose from the following seven courses—Geography, Japanese, Macroeconomics, Psychology, Russian, Statistics (which is offered twice, once each on Tuesdays at 9 A.M. and 3 P.M.), and World History. No one is allowed to take any course more than once per semester. Because of university requirements and time conflicts, the following restrictions apply to Alicia's choices: She must take Japanese if she does not take Russian. She cannot take Japanese if she takes Macroeconomics. She cannot take World History if she takes Statistics at 9 A.M. She must take Statistics at 9 A.M. if she takes Psychology. She must take either Geography or World History but cannot take both.
Question:
Suppose that Alicia must take Statistics if she takes Psychology, but rather than being restricted to taking Statistics at 9 A.M. she can take it at either 9 A.M. or at 3 P.M. If all the other restrictions remain the same, then which one of the following could be the list of the four courses Alicia takes?
Choices:
(A) Psychology, Russian, Statistics, World History
(B) Macroeconomics, Psychology, Statistics, World History
(C) Macroeconomics, Psychology, Russian, World History
(D) Geography, Psychology, Russian, World History
(E) Geography, Macroeconomics, Russian, World History
###"
"# Declarations
interns = EnumSort([Farber, Gombarick, Hall, Jackson, Kanze, Lha])
stories = EnumSort([Romania, Spain, Tuscany])
assigned = Function([interns, stories] -> [bool])

# Constraints
ForAll([i:interns], Or(assigned(i, Romania), assigned(i, Spain), assigned(i, Tuscany))) ::: Each intern will be trained either as a photographer's assistant or as a writer's assistant
assigned(Gombarick, Romania) == assigned(Lha, Romania) ::: Gombarick and Lha will be trained in the same field
assigned(Farber, Romania)!= assigned(Kanze, Romania) ::: Farber and Kanze will be trained in different fields
assigned(Hall, Romania) ::: Hall will be trained as a photographer's assistant
assigned(Jackson, Tuscany) ::: Jackson is assigned to Tuscany
assigned(Kanze, Spain) == False ::: Kanze is not assigned to Spain

# Options
Question ::: Which one of the following could be an acceptable assignment of photographer's assistants to stories?
is_sat(assigned(Farber, Romania) == True) ::: (A)
is_sat(assigned(Gombarick, Romania) == True) ::: (B)
is_sat(assigned(Gombarick, Romania) == True) ::: (C)
is_sat(assigned(Gombarick, Romania) == True) ::: (D)
is_sat(assigned(Hall, Romania) == True) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A travel magazine has hired six interns—Farber, Gombarick, Hall, Jackson, Kanze, and Lha—to assist in covering three stories—Romania, Spain, and Tuscany. Each intern will be trained either as a photographer's assistant or as a writer's assistant. Each story is assigned a team of two interns—one photographer's assistant and one writer's assistant—in accordance with the following conditions: Gombarick and Lha will be trained in the same field. Farber and Kanze will be trained in different fields. Hall will be trained as a photographer's assistant. Jackson is assigned to Tuscany. Kanze is not assigned to Spain.
Question:
Which one of the following could be an acceptable assignment of photographer's assistants to stories?
Choices:
(A) Romania: Farber Spain: Hall Tuscany: Jackson
(B) Romania: Gombarick Spain: Hall Tuscany: Farber
(C) Romania: Gombarick Spain: Hall Tuscany: Lha
(D) Romania: Gombarick Spain: Lha Tuscany: Kanze
(E) Romania: Hall Spain: Kanze Tuscany: Jackson
###"
"# Declarations
artifacts = EnumSort([figurine, headdress, jar, necklace, plaque, tureen])
ages = Function([artifacts] -> [int])
ForAll([a:artifacts], 1 <= ages(a))
ForAll([a:artifacts], ages(a) <= 6)

# Constraints
ForAll([a:artifacts], And(a!= figurine, a!= jar, a!= headdress, a!= necklace, a!= plaque, a!= tureen)) ::: no two of which are the same age
And(ages(figurine) < ages(jar), ages(figurine) < ages(headdress)) ::: The figurine is older than both the jar and the headdress
And(ages(necklace) < ages(tureen), ages(jar) < ages(tureen)) ::: The necklace and the jar are both older than the tureen
Or(And(ages(plaque) < ages(headdress), ages(plaque) < ages(necklace)), And(ages(headdress) < ages(plaque), ages(necklace) < ages(plaque))) ::: Either the plaque is older than both the headdress and the necklace, or both the headdress and the necklace are older than the plaque

# Options
Question ::: Which one of the following artifacts CANNOT be fourth?
is_exception(is_sat(ages(figurine) == 4)) ::: (A)
is_exception(is_sat(ages(headdress) == 4)) ::: (B)
is_exception(is_sat(ages(jar) == 4)) ::: (C)
is_exception(is_sat(ages(necklace) == 4)) ::: (D)
is_exception(is_sat(ages(plaque) == 4)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
An archaeologist has six ancient artifacts—a figurine, a headdress, a jar, a necklace, a plaque, and a tureen—no two of which are the same age. She will order them from first (oldest) to sixth (most recent). The following has already been determined: The figurine is older than both the jar and the headdress. The necklace and the jar are both older than the tureen. Either the plaque is older than both the headdress and the necklace, or both the headdress and the necklace are older than the plaque.
Question:
Which one of the following artifacts CANNOT be fourth?
Choices:
(A) figurine
(B) headdress
(C) jar
(D) necklace
(E) plaque
###"
"# Declarations
films = EnumSort([Fiesta, Glaciers, Hurricanes, Jets, Kangaroos, Lovebird])
released = Function([films] -> [int])
ForAll([f:films], And(1 <= released(f), released(f) <= 6))

# Constraints
Distinct([f:films], released(f)) ::: No two of these films can be released on the same date
And(released(Fiesta) < released(Jets), released(Fiesta) < released(Lovebird)) ::: Fiesta must be released earlier than both Jets and Lovebird
And(released(Kangaroos) < released(Jets), released(Jets) < released(Hurricanes)) ::: Kangaroos must be released earlier than Jets, and Jets must be released earlier than Hurricanes
released(Lovebird) < released(Glaciers) ::: Lovebird must be released earlier than Glaciers

# Options
Question ::: Which one of the following must be true?
is_sat(released(Fiesta) < released(Hurricanes)) ::: (A)
is_sat(released(Jets) < released(Glaciers)) ::: (B)
is_sat(released(Kangaroos) < released(Glaciers)) ::: (C)
is_sat(released(Lovebird) < released(Hurricanes)) ::: (D)
is_sat(released(Lovebird) < released(Jets)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A movie studio is scheduling the release of six films—Fiesta, Glaciers, Hurricanes, Jets, Kangaroos, and Lovebird. No two of these films can be released on the same date. The release schedule is governed by the following conditions: Fiesta must be released earlier than both Jets and Lovebird. Kangaroos must be released earlier than Jets, and Jets must be released earlier than Hurricanes. Lovebird must be released earlier than Glaciers.
Question:
Which one of the following must be true?
Choices:
(A) Fiesta is released earlier than Hurricanes.
(B) Jets is released earlier than Glaciers.
(C) Kangaroos is released earlier than Glaciers.
(D) Lovebird is released earlier than Hurricanes.
(E) Lovebird is released earlier than Jets.
###"
"# Declarations
films = EnumSort([Fiesta, Glaciers, Hurricanes, Jets, Kangaroos, Lovebird])
released = Function([films] -> [int])
ForAll([f:films], And(1 <= released(f), released(f) <= 6))

# Constraints
Distinct([f:films], released(f)) ::: no two of these films can be released on the same date
And(released(Fiesta) < released(Jets), released(Fiesta) < released(Lovebird)) ::: Fiesta must be released earlier than both Jets and Lovebird
And(released(Kangaroos) < released(Jets), released(Jets) < released(Hurricanes)) ::: Kangaroos must be released earlier than Jets, and Jets must be released earlier than Hurricanes
released(Lovebird) < released(Glaciers) ::: Lovebird must be released earlier than Glaciers

# Options
Question ::: Which one of the following, if substituted for the condition that Fiesta must be released earlier than both Jets and Lovebird, would have the same effect on the order in which the films are released?
is_sat(ForAll([f:films], Implies(f == Kangaroos, released(f) < released(Fiesta)))) ::: (A)
is_sat(ForAll([f:films], Implies(f == Lovebird, released(f) < released(Kangaroos)))) ::: (B)
is_sat(ForAll([f:films], Or(released(f) == 1, released(f) == 2))) ::: (C)
is_sat(ForAll([f:films], And(released(f) < released(Kangaroos), released(f) < released(Lovebird)))) ::: (D)
is_sat(Exists([f:films], Or(released(f) == 1, released(f) == 2))) ::: (------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A movie studio is scheduling the release of six films—Fiesta, Glaciers, Hurricanes, Jets, Kangaroos, and Lovebird. No two of these films can be released on the same date. The release schedule is governed by the following conditions: Fiesta must be released earlier than both Jets and Lovebird. Kangaroos must be released earlier than Jets, and Jets must be released earlier than Hurricanes. Lovebird must be released earlier than Glaciers.
Question:
Which one of the following, if substituted for the condition that Fiesta must be released earlier than both Jets and Lovebird, would have the same effect on the order in which the films are released?
Choices:
(A) Only Kangaroos can be released earlier than Fiesta.
(B) Kangaroos must be released earlier than Lovebird.
(C) Fiesta must be released either first or second.
(D) Fiesta must be released earlier than both Kangaroos and Lovebird.
(E) Either Fiesta or Kangaroos must be released first.
###"
"# Declarations
artifacts = EnumSort([V, W, X, Y, Z])
origins = EnumSort([Iceland, Norway, Sweden])
originates = Function([artifacts] -> [origins])

# Constraints
originates(W) == originates(Y) ::: W and Y originated in the same country
originates(X) == Norway or originates(X) == Sweden ::: X originated in Norway or Sweden
Count([a:artifacts], originates(a) == Iceland) > Count([a:artifacts], originates(a) == Norway) ::: More of the artifacts originated in Iceland than in Norway
Implies(originates(V) == Iceland, originates(Z) == Sweden) ::: If V originated in Iceland, then Z originated in Sweden
originates(Y) == Iceland ::: Y originated in Iceland

# Options
Question ::: If Y and Z originated in Iceland, then what is the minimum number of artifacts that originated in Sweden?
is_sat(Count([a:artifacts], originates(a) == Sweden) >= 0) ::: (A)
is_sat(Count([a:artifacts], originates(a) == Sweden) >= 1) ::: (B)
is_sat(Count([a:artifacts], originates(a) == Sweden) >= 2) ::: (C)
is_sat(Count([a:artifacts], originates(a) == Sweden) >= 3) ::: (D)
is_sat(Count([a:artifacts], originates(a) == Sweden) >= 4) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Five artifacts—V, W, X, Y, and Z—recovered from a sunken ship are each known to have originated in Iceland, Norway, or Sweden. These artifacts, together with the surviving fragments of a cargo list, have enabled historians to determine the following: W and Y originated in the same country. X originated in Norway or Sweden. More of the artifacts originated in Iceland than in Norway. If V originated in Iceland, then Z originated in Sweden.
Question:
If Y and Z originated in Iceland, then what is the minimum number of artifacts that originated in Sweden?
Choices:
(A) zero
(B) one
(C) two
(D) three
(E) four
###"
"# Declarations
weeks = EnumSort([1, 2, 3, 4, 5, 6, 7])
destinations = EnumSort([Guadeloupe, Jamaica, Martinique, Trinidad])
voyages = Function([weeks, destinations] -> [bool])

# Constraints
ForAll([d:destinations], Exists([w:weeks], voyages(w, d))) ::: Each destination will be scheduled for at least one of the weeks
Not(voyages(4, Jamaica)) ::: Jamaica will not be its destination in week 4
voyages(7, Trinidad) ::: Trinidad will be its destination in week 7
Count([w:weeks], voyages(w, Martinique)) == 2 ::: Freedom will make exactly two voyages to Martinique
Exists([w:weeks], And(w!= 7, voyages(w, Guadeloupe), voyages(w + 1, Jamaica))) ::: at least one voyage to Guadeloupe will occur in some week between those two voyages
ForAll([w:weeks], Not(voyages(w, Guadeloupe), voyages(w + 1, Guadeloupe))) ::: No destination will be scheduled for consecutive weeks

# Options
Question ::: Which one of the following CANNOT be true about Freedom's schedule of voyages?
is_exception(is_sat(voyages(6, Trinidad))) ::: (A)
is_exception(is_sat(voyages(5, Martinique))) ::: (B)
is_exception(is_sat(voyages(6, Jamaica))) ::: (C)
is_exception(is_sat(voyages(3, Jamaica))) ::: (D)
is_exception(is_sat(voyages(3, Guadeloupe))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A cruise line is scheduling seven week-long voyages for the ship Freedom. Each voyage will occur in exactly one of the first seven weeks of the season: weeks 1 through 7. Each voyage will be to exactly one of four destinations: Guadeloupe, Jamaica, Martinique, or Trinidad. Each destination will be scheduled for at least one of the weeks. The following conditions apply to Freedom's schedule: Jamaica will not be its destination in week 4. Trinidad will be its destination in week 7. Freedom will make exactly two voyages to Martinique, and at least one voyage to Guadeloupe will occur in some week between those two voyages. Guadeloupe will be its destination in the week preceding any voyage it makes to Jamaica. No destination will be scheduled for consecutive weeks.
Question:
Which one of the following CANNOT be true about Freedom's schedule of voyages?
Choices:
(A) Freedom makes a voyage to Trinidad in week 6.
(B) Freedom makes a voyage to Martinique in week 5.
(C) Freedom makes a voyage to Jamaica in week 6.
(D) Freedom makes a voyage to Jamaica in week 3.
(E) Freedom makes a voyage to Guadeloupe in week 3.
###"
"# Declarations
weeks = EnumSort([1, 2, 3, 4, 5, 6, 7])
destinations = EnumSort([Guadeloupe, Jamaica, Martinique, Trinidad])
voyages = Function([weeks, destinations] -> [bool])

# Constraints
ForAll([d:destinations], Exists([w:weeks], voyages(w, d))) ::: Each destination will be scheduled for at least one of the weeks
Not(voyages(4, Jamaica)) ::: Jamaica will not be its destination in week 4
voyages(7, Trinidad) ::: Trinidad will be its destination in week 7
Count([w:weeks], voyages(w, Martinique)) == 2 ::: Freedom will make exactly two voyages to Martinique
Exists([w:weeks], And(w > 1, w < 7, voyages(w, Guadeloupe), Exists([w2:weeks], And(w2 > w, w2 < 7, voyages(w2, Guadeloupe))))) ::: at least one voyage to Guadeloupe will occur in some week between those two voyages
ForAll([w:weeks], Implies(voyages(w, Guadeloupe), Not(voyages(w + 1, Jamaica)))) ::: Guadeloupe will be its destination in the week preceding any voyage it makes to Jamaica
ForAll([w:weeks], ForAll([d:destinations], Implies(voyages(w, d), Not(voyages(w + 1, d))))) ::: No destination will be scheduled for consecutive weeks

# Options
Question ::: If Freedom makes a voyage to Guadeloupe in week 1 and to Trinidad in week 2, which one of the following must be true?
is_sat(voyages(1, Guadeloupe) & voyages(2, Trinidad)) :::
is_sat(voyages(3, Martinique)) ::: (A)
is_sat(voyages(4, Martinique)) ::: (B)
is_sat(voyages(5, Martinique)) ::: (C)
is_sat(voyages(3, Guadeloupe)) ::: (D)
is_sat(voyages(5, Guadeloupe)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A cruise line is scheduling seven week-long voyages for the ship Freedom. Each voyage will occur in exactly one of the first seven weeks of the season: weeks 1 through 7. Each voyage will be to exactly one of four destinations: Guadeloupe, Jamaica, Martinique, or Trinidad. Each destination will be scheduled for at least one of the weeks. The following conditions apply to Freedom's schedule: Jamaica will not be its destination in week 4. Trinidad will be its destination in week 7. Freedom will make exactly two voyages to Martinique, and at least one voyage to Guadeloupe will occur in some week between those two voyages. Guadeloupe will be its destination in the week preceding any voyage it makes to Jamaica. No destination will be scheduled for consecutive weeks.
Question:
If Freedom makes a voyage to Guadeloupe in week 1 and to Trinidad in week 2, which one of the following must be true?
Choices:
(A) Freedom makes a voyage to Martinique in week 3.
(B) Freedom makes a voyage to Martinique in week 4.
(C) Freedom makes a voyage to Martinique in week 5.
(D) Freedom makes a voyage to Guadeloupe in week 3.
(E) Freedom makes a voyage to Guadeloupe in week 5.
###"
"# Declarations
weeks = EnumSort([1, 2, 3, 4, 5, 6, 7])
destinations = EnumSort([Guadeloupe, Jamaica, Martinique, Trinidad])
voyages = Function([weeks, destinations] -> [bool])

# Constraints
ForAll([d:destinations], Exists([w:weeks], voyages(w, d))) ::: Each destination will be scheduled for at least one of the weeks
Not(voyages(4, Jamaica)) ::: Jamaica will not be its destination in week 4
voyages(7, Trinidad) ::: Trinidad will be its destination in week 7
Count([w:weeks], voyages(w, Martinique)) == 2 ::: Freedom will make exactly two voyages to Martinique
Exists([w:weeks], And(w!= 7, voyages(w, Guadeloupe), voyages(w + 1, Jamaica))) ::: at least one voyage to Guadeloupe will occur in some week between those two voyages
ForAll([w:weeks], ForAll([d:destinations], Implies(voyages(w, d), Not(voyages(w + 1, d))))) ::: No destination will be scheduled for consecutive weeks

# Options
Question ::: If Freedom makes a voyage to Martinique in week 3, which one of the following could be an accurate list of Freedom's destinations in week 4 and week 5, respectively?
is_sat(And(voyages(4, Guadeloupe), voyages(5, Trinidad))) ::: A) Guadeloupe, Trinidad
is_sat(And(voyages(4, Jamaica), voyages(5, Guadeloupe))) ::: B) Jamaica, Guadeloupe
is_sat(And(voyages(4, Martinique), voyages(5, Trinidad))) ::: C) Martinique, Trinidad
is_sat(And(voyages(4, Trinidad), voyages(5, Jamaica))) ::: D) Trinidad, Jamaica
is_sat(And(voyages(4, Trinidad), voyages(5, Martinique))) ::: E) Trinidad, Martinique
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A cruise line is scheduling seven week-long voyages for the ship Freedom. Each voyage will occur in exactly one of the first seven weeks of the season: weeks 1 through 7. Each voyage will be to exactly one of four destinations: Guadeloupe, Jamaica, Martinique, or Trinidad. Each destination will be scheduled for at least one of the weeks. The following conditions apply to Freedom's schedule: Jamaica will not be its destination in week 4. Trinidad will be its destination in week 7. Freedom will make exactly two voyages to Martinique, and at least one voyage to Guadeloupe will occur in some week between those two voyages. Guadeloupe will be its destination in the week preceding any voyage it makes to Jamaica. No destination will be scheduled for consecutive weeks.
Question:
If Freedom makes a voyage to Martinique in week 3, which one of the following could be an accurate list of Freedom's destinations in week 4 and week 5, respectively?
Choices:
(A) Guadeloupe, Trinidad
(B) Jamaica, Guadeloupe
(C) Martinique, Trinidad
(D) Trinidad, Jamaica
(E) Trinidad, Martinique
###"
"# Declarations
medicines = EnumSort([W, X, Y, Z])
side_effects = EnumSort([fatigue, headaches, palpitations, sweating])
has_side_effect = Function([medicines, side_effects] -> [bool])

# Constraints
ForAll([m:medicines], Exists([s:side_effects], has_side_effect(m, s))) ::: Each medicine has at least one side effect
ForAll([m:medicines], Not(And(has_side_effect(m, fatigue), has_side_effect(m, palpitations)))) ::: No medicine has both fatigue and palpitations as side effects
ForAll([s:side_effects], Not(And(has_side_effect(Z, s), Or(has_side_effect(W, s), has_side_effect(X, s), has_side_effect(Y, s))))) ::: Medicine Z has no side effect in common with any of the other medicines
And(has_side_effect(W, fatigue), has_side_effect(X, palpitations)) ::: Medicines W and X have exactly one side effect in common
And(has_side_effect(W, fatigue), Not(has_side_effect(Y, sweating))) ::: Fatigue is a side effect of medicine W. Sweating is not a side effect of medicine Y.

# Options
Question ::: Which one of the following statements could be true?
is_sat(has_side_effect(X, fatigue)) ::: (A)
is_sat(has_side_effect(Z, fatigue)) ::: (B)
is_sat(has_side_effect(X, headaches)) ::: (C)
is_sat(has_side_effect(W, palpitations)) ::: (D)
is_sat(has_side_effect(Z, palpitations)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A researcher is evaluating exactly four medicines: W, X, Y, and Z. The only side effects the medicines can have are fatigue, headaches, palpitations, and sweating. The researcher knows the following to be true of the medicines side effects: Each medicine has at least one side effect. No medicine has both fatigue and palpitations as side effects. Medicine Z has no side effect in common with any of the other medicines. Medicines W and X have exactly one side effect in common. Fatigue is a side effect of medicine W. Palpitations are a side effect of medicine X. Sweating is not a side effect of medicine Y.
Question:
Which one of the following statements could be true?
Choices:
(A) Fatigue is a side effect of medicine X.
(B) Fatigue is a side effect of medicine Z.
(C) Headaches are a side effect of medicine X.
(D) Palpitations are a side effect of medicine W.
(E) Palpitations are a side effect of medicine Z.
###"
"# Declarations
medicines = EnumSort([W, X, Y, Z])
side_effects = EnumSort([fatigue, headaches, palpitations, sweating])
has_side_effect = Function([medicines, side_effects] -> [bool])

# Constraints
ForAll([m:medicines], Exists([s:side_effects], has_side_effect(m, s))) ::: Each medicine has at least one side effect
ForAll([m:medicines], Not(And(has_side_effect(m, fatigue), has_side_effect(m, palpitations)))) ::: No medicine has both fatigue and palpitations as side effects
ForAll([s:side_effects], Not(has_side_effect(Z, s))) ::: Medicine Z has no side effect in common with any of the other medicines
And(has_side_effect(W, fatigue), has_side_effect(X, palpitations)) ::: Medicines W and X have exactly one side effect in common
Not(has_side_effect(Y, sweating)) ::: Sweating is not a side effect of medicine Y

# Options
Question ::: If medicine Y has more than one side effect, then which one of the following statements must be true?
is_valid(has_side_effect(Y, headaches)) ::: (A)
is_valid(has_side_effect(Y, palpitations)) ::: (B)
is_valid(has_side_effect(W, sweating)) ::: (C)
is_valid(Not(has_side_effect(Y, palpitations))) ::: (D)
is_valid(Not(has_side_effect(Z, sweating))) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
A researcher is evaluating exactly four medicines: W, X, Y, and Z. The only side effects the medicines can have are fatigue, headaches, palpitations, and sweating. The researcher knows the following to be true of the medicines side effects: Each medicine has at least one side effect. No medicine has both fatigue and palpitations as side effects. Medicine Z has no side effect in common with any of the other medicines. Medicines W and X have exactly one side effect in common. Fatigue is a side effect of medicine W. Palpitations are a side effect of medicine X. Sweating is not a side effect of medicine Y.
Question:
If medicine Y has more than one side effect, then which one of the following statements must be true?
Choices:
(A) Headaches are a side effect of medicine Y.
(B) Palpitations are a side effect of medicine Y.
(C) Sweating is a side effect of medicine W.
(D) Palpitations are not a side effect of medicine Y.
(E) Sweating is not a side effect of medicine Z.
###"
"# Declarations
stores = EnumSort([Faroj_Appliances, Good_Buy, Intelligent_Office, LANs_for_Less, Networks_Unlimited, Silicon_Village, Uptown_Computing])
sold = Function([stores] -> [int])
ForAll([s:stores], And(100 <= sold(s), sold(s) <= 500))

# Constraints
sold(Good_Buy) == sold(Networks_Unlimited) ::: Good Buy sold exactly the same number of computers as Networks Unlimited did
sold(Intelligent_Office) == sold(Uptown_Computing) ::: Intelligent Office sold exactly the same number of computers as Uptown Computing did
ForAll([s:stores], Implies(s == Faroj_Appliances, Implies(s == Silicon_Village, sold(s)!= sold(Faroj_Appliances)))) ::: Neither Faroj's Appliances nor Silicon Village sold exactly the same number of computers as any other store
sold(LANs_for_Less) > sold(Uptown_Computing) ::: LANs for Less sold more computers than Uptown Computing did
sold(Intelligent_Office) > sold(Good_Buy) ::: Intelligent Office sold more computers than Good Buy did

# Options
Question ::: Which one of the following must be true?
is_valid(sold(Faroj_Appliances) > sold(Good_Buy)) ::: (A)
is_valid(sold(Intelligent_Office) > sold(Silicon_Village)) ::: (B)
is_valid(sold(LANs_for_Less) > sold(Faroj_Appliances)) ::: (C)
is_valid(sold(Silicon_Village) > sold(Good_Buy)) ::: (D)
is_valid(sold(Uptown_Computing) > sold(Networks_Unlimited)) ::: (E)
------","Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.
Declarations: Declare the variables and functions.
Constraints: Write the constraints in the problem description as logic formulas.
Options: Write the options in the question as logic formulas.
------
Problem:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
Question:
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
###
# Declarations
people = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])
eats = Function([people, meals] -> [foods])

# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch

# Options
Question ::: Vladimir must eat which one of the following foods?
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)
------
Problem:
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
Question:
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
###
# Declarations
technicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])
machines = EnumSort([radios, televisions, VCRs])
repairs = Function([technicians, machines] -> [bool])

# Constraints
ForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types
And(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios
And(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs
ForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs
Count([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs
ForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs
Count([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines

# Options
Question ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
is_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)
is_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)
is_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)
is_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)
------
Problem:
Workers at a water treatment plant open eight valves—G, H, I, K, L, N, O, and P—to flush out a system of pipes that needs emergency repairs. To maximize safety and efficiency, each valve is opened exactly once, and no two valves are opened at the same time. The valves are opened in accordance with the following conditions: Both K and P are opened before H. O is opened before L but after H. L is opened after G. N is opened before H. I is opened after K.
Question: Each of the following could be the fifth valve opened EXCEPT:
Choices:
(A) H
(B) I
(C) K
(D) N
(E) O
""""""
# Declarations
valves = EnumSort([G, H, I, K, L, N, O, P])
opened = Function([valves] -> [int])
ForAll([v:valves], And(1 <= opened(v), opened(v) <= 8))

# Constraints
Distinct([v:valves], opened(v)) ::: no two valves are opened at the same time
And(opened(K) < opened(H), opened(P) < opened(H)) ::: Both K and P are opened before H
And(opened(O) > opened(H), opened(O) < opened(L)) ::: O is opened before L but after H
opened(L) > opened(G) ::: L is opened after G
opened(N) < opened(H) ::: N is opened before H
opened(I) > opened(K) ::: I is opened after K

# Options
Question ::: Each of the following could be the fifth valve opened EXCEPT:
is_exception(is_sat(opened(H) == 5)) ::: (A)
is_exception(is_sat(opened(I) == 5)) ::: (B)
is_exception(is_sat(opened(K) == 5)) ::: (C)
is_exception(is_sat(opened(N) == 5)) ::: (D)
is_exception(is_sat(opened(O) == 5)) ::: (E)
------
Problem:
Last year, seven stores—Faroj's Appliances, Good Buy, Intelligent Office, LANs for Less, Networks Unlimited, Silicon Village, and Uptown Computing—each sold exactly 100, 200, 300, 400, or 500 computers, consistent with the following conditions: Good Buy sold exactly the same number of computers as Networks Unlimited did. Intelligent Office sold exactly the same number of computers as Uptown Computing did. Neither Faroj's Appliances nor Silicon Village sold exactly the same number of computers as any other store. LANs for Less sold more computers than Uptown Computing did. Intelligent Office sold more computers than Good Buy did.
Question:
Which one of the following must be true?
Choices:
(A) Faroj's Appliances sold more computers last year than Good Buy did.
(B) Intelligent Office sold more computers last year than Silicon Village did.
(C) LANs for Less sold more computers last year than Faroj's Appliances did.
(D) Silicon Village sold more computers last year than Good Buy did.
(E) Uptown Computing sold more computers last year than Networks Unlimited did.
###"
